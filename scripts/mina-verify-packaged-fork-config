#!/usr/bin/env bash

set -eo pipefail

if [ $# -lt 3 ]; then
    echo "Usage: $0 <network-name> <fork-config.json> <working-dir> <optional: precomputed block prefix>"
    cat <<EOF
This script is used to validate that an installed package is correct
according to an exported fork_config.json file.

Inputs:
- The exported mainnet full config.json fork config, with all accounts
- A working directory where ledgers/configs will be created
- Installed MINA_EXE (default: mina) and MINA_GENESIS_EXE (default: mina-create-genesis) programs
- Installed MINA_LEGACY_GENESIS_EXE program (default: mina-legacy-create-genesis)
- PACKAGED_DAEMON_CONFIG (default: /var/lib/coda/config_*.json)
  the runtime config generated by the HF packaging
- CREATE_RUNTIME_CONFIG (default: mina-hf-create-runtime-config)
  a copy of ./scripts/hardfork/create_runtime_config.sh
- GENESIS_LEDGER_DIR (default: /var/lib/coda)
  where the tarfiles to verify are stored
- FORKING_FROM_CONFIG_JSON (default: /var/lib/coda/mainnet.json)
  the pre-fork genesis ledger
- SECONDS_PER_SLOT (default: 180)
- PRECOMPUTED_FORK_BLOCK (default: fetches with gsutil)
- GSUTIL (default: gsutil)
  the Google Cloud Storage utility if the PRECOMPUTED_FORK_BLOCK isn't a file

Ensures:
- The accounts listed in config.json are the ones in the PACKAGED_DAEMON_CONFIG
- The genesis ledger directory tarfile contents match reference copies created
  fresh from config.json. This takes a long time (>20min) due to rehashing.

Outputs:
- Exit code 0 if validated, 1 otherwise.
EOF

    exit 1
fi

source_build_fallback() {
    v=$(command -v "$1")
    if [ ! -x "$v" ]; then
        if [ ! -x "$2" ]; then
            echo "Error: program not found in PATH (as $1) or relative to cwd (as $2)" >&2
            exit 1
        else
            echo "$2"
        fi
    else
      echo "$1"
    fi
}

MINA_EXE=${MINA_EXE:-$(source_build_fallback mina ./_build/default/src/app/cli/src/mina.exe)}
MINA_GENESIS_EXE=${MINA_GENESIS_EXE:-$(source_build_fallback mina-create-genesis ./_build/default/src/app/runtime_genesis_ledger/runtime_genesis_ledger.exe)}
MINA_LEGACY_GENESIS_EXE=${MINA_LEGACY_GENESIS_EXE:-$(source_build_fallback mina-create-legacy-genesis ./runtime_genesis_ledger_of_mainnet.exe)}
CREATE_RUNTIME_CONFIG=${CREATE_RUNTIME_CONFIG:-$(source_build_fallback mina-hf-create-runtime-config ./scripts/hardfork/create_runtime_config.sh)}
GSUTIL=${GSUTIL:-$(source_build_fallback gsutil false)}

if [[ -e "$PRECOMPUTED_FORK_BLOCK"  && ! -x "$GSUTIL" ]]; then
    echo "Error: gsutil is required when PRECOMPUTED_FORK_BLOCK is nonexistent path"
    exit 1
fi

installed_config=$(echo /var/lib/coda/config_*.json)
PACKAGED_DAEMON_CONFIG=${PACKAGED_DAEMON_CONFIG:-$installed_config}
if [ ! -e "$installed_config" ]; then
    echo "Error: set PACKAGED_DAEMON_CONFIG to the path to the JSON file to verify"
    exit 1
fi


GENESIS_LEDGER_DIR=${GENESIS_LEDGER_DIR:-"/var/lib/coda"}

SECONDS_PER_SLOT=${SECONDS_PER_SLOT:=180}

export FORKING_FROM_CONFIG_JSON=${FORKING_FROM_CONFIG_JSON:-$(source_build_fallback /var/lib/coda/mainnet.json genesis_ledgers/mainnet.json)}

export MINA_LIBP2P_PASS=''

workdir=$3
mkdir -p "$workdir"/{ledgers{,-backup},keys}
chmod 700 "$workdir/keys"

fork_block_state_hash=$(jq -r '.proof.fork.state_hash' "$2")
fork_block_length=$(jq -r '.proof.fork.blockchain_length' "$2")

# Put the fork block where we want it, fetch it from gcloud if necessary
if [ ! -e "$PRECOMPUTED_FORK_BLOCK" ]; then
    if [ "$PRECOMPUTED_FORK_BLOCK" = "" ]; then
        prefix=$4
        if [ "$prefix" = "" ]; then
            prefix="gs://mina_network_block_data/$1"
        fi
        PRECOMPUTED_FORK_BLOCK="$prefix-$fork_block_length-$fork_block_state_hash.json"
    fi
    "$GSUTIL" cp "$PRECOMPUTED_FORK_BLOCK" "$workdir/precomputed_fork_block.json"
else
    cp "$PRECOMPUTED_FORK_BLOCK" "$workdir/precomputed_fork_block.json"
fi


if [ ! -e "$workdir/keys/p2p" ]; then
    "$MINA_EXE" libp2p generate-keypair --privkey-path "$workdir/keys/p2p"
fi

echo "generating genesis ledgers ... (this may take a while)" >&2

cp "$2" "$workdir/config_orig.json"

# Patch against a bug in 1.4 which is fixed by PR #15462
jq 'del(.ledger.num_accounts) | del(.ledger.name)' "$workdir/config_orig.json" > "$workdir/config.json" 

"$MINA_LEGACY_GENESIS_EXE" --config-file "$workdir/config.json" --genesis-dir "$workdir/legacy_ledgers" --hash-output-file "$workdir/legacy_hashes.json"

result=$(jq --slurpfile block "$workdir/precomputed_fork_block.json" \
  --slurpfile legacy_hashes "$workdir/legacy_hashes.json" -n '
  ($legacy_hashes[0].epoch_data.staking.hash == $block[0].protocol_state.body.consensus_state.staking_epoch_data.ledger.hash and
   $legacy_hashes[0].epoch_data.next.hash == $block[0].protocol_state.body.consensus_state.next_epoch_data.ledger.hash and
   $legacy_hashes[0].ledger.hash == $block[0].protocol_state.body.blockchain_state.staged_ledger_hash.non_snark.ledger_hash)')

if [ "$result" != "true" ]; then
    echo "Hashes in config $2 don't match hashes from the precomputed block $PRECOMPUTED_FORK_BLOCK" >&2
    exit 1
fi

sed -i -e 's/"set_verification_key": "signature"/"set_verification_key": {"auth": "signature", "txn_version": "2"}/g' "$workdir/config.json"
"$MINA_GENESIS_EXE" --config-file "$workdir/config.json" --genesis-dir "$workdir/ledgers" --hash-output-file "$workdir/hashes.json"

FORK_CONFIG_JSON="$2" \
LEDGER_HASHES_JSON="$workdir/hashes.json" \
GENESIS_TIMESTAMP=$(jq -r '.genesis.genesis_state_timestamp' "$PACKAGED_DAEMON_CONFIG") \
"$CREATE_RUNTIME_CONFIG" > "$workdir/config-substituted.json"

echo "exporting ledgers from running node ... (this may take a while)" >&2

override_file="$workdir/override-genesis-timestamp.json"
echo "{\"genesis\":{\"genesis_state_timestamp\":\"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\"}}" > "$override_file"

# export the packaged ledgers in a way where we know which one is which
function extract_ledgers() {
    config_file=$1
    ledger_dir=$2
    json_prefix=$3
    "$MINA_EXE" daemon --libp2p-keypair "$workdir/keys/p2p" \
      --config-file "$config_file" --config-file "$override_file" \
      --seed --genesis-ledger-dir "$ledger_dir" &

    while ! "$MINA_EXE" ledger export staged-ledger  | jq . 2>/dev/null >"$json_prefix-staged.json"; do
        sleep 1m
        if ! grep -qFx "$(cat ~/.mina-config/.mina-lock)" <(jobs -rp); then
            echo "daemon died before exporting ledgers" >&2
            exit 1
        fi
    done

    "$MINA_EXE" ledger export staking-epoch-ledger | jq . > "$json_prefix-staking.json"
    "$MINA_EXE" ledger export next-epoch-ledger | jq . > "$json_prefix-next.json"

    "$MINA_EXE" client stop
}

mkdir -p "$workdir/ledgers-downloaded"

mv -t "$workdir/ledgers-backup" "$GENESIS_LEDGER_DIR"/*.tar.gz
if [ -z ${NO_TEST_LEDGER_DOWNLOAD+z} ]; then
    # We removed all *.tar.gz from GENESIS_LEDGER_DIR (in case it's one of default paths)
    # and expect Mina node to be able to download these from S3
    extract_ledgers "$PACKAGED_DAEMON_CONFIG" "$workdir/ledgers-downloaded" "$workdir/downloaded"
    rm -Rf /tmp/coda_cache_dir/*.tar.gz /tmp/s3_cache_dir/*.tar.gz
fi
extract_ledgers "$workdir/config-substituted.json" "$workdir/ledgers" "$workdir/reference"
mv -t "$GENESIS_LEDGER_DIR" "$workdir/ledgers-backup"/*
extract_ledgers "$PACKAGED_DAEMON_CONFIG" "$GENESIS_LEDGER_DIR" "$workdir/packaged"

echo "Performing final comparisons..." >&2
error=0

result=$(jq --slurpfile a "$workdir/config-substituted.json" --slurpfile b "$PACKAGED_DAEMON_CONFIG" -n '
  ($a[0].epoch_data.staking.hash == $b[0].epoch_data.staking.hash and
   $a[0].epoch_data.next.hash == $b[0].epoch_data.next.hash and
   $a[0].ledger.hash == $b[0].ledger.hash)')

if [ "$result" != "true" ]; then
    echo "Packaged config hashes in $PACKAGED_DAEMON_CONFIG not expected compared to $workdir/config-substituted.json" >&2
    error=1
fi

for file in "$workdir"/packaged-*.json; do
    name=$(basename "$file")
    name=${name%.json}
    name=${name#packaged-}

    if ! cmp "$file" "$workdir/reference-$name.json"; then
        echo "Error: $file does not match reference" >&2
        error=1
    fi
    if [ -z ${NO_TEST_LEDGER_DOWNLOAD+z} ]; then
        if ! cmp "$file" "$workdir/downloaded-$name.json"; then
            echo "Error: $file does not match downloaded" >&2
            error=1
        fi
    fi
done

ldb_cmd=$(command -v rocksdb-ldb || command -v rocksdb_ldb || command -v ldb)
for file in "$workdir"/ledgers/*.tar.gz; do
    tarname=$(basename "$file")
    tarname=${tarname%.tar.gz}
    tardir="$workdir/ledgers/$tarname"
    mkdir -p "$tardir"/{packaged,generated,web}
    tar -xzf "$file" -C "$tardir/generated"
    tar -xzf "$GENESIS_LEDGER_DIR/$tarname.tar.gz" -C "$tardir/packaged"
    curl "https://s3-us-west-2.amazonaws.com/snark-keys.o1test.net/$tarname.tar.gz" | tar -xz -C "$tardir/web"

    $ldb_cmd --hex --db="$tardir/packaged" scan > "$workdir/packaged.scan"
    $ldb_cmd --hex --db="$tardir/web" scan > "$workdir/web.scan"
    $ldb_cmd --hex --db="$tardir/generated" scan > "$workdir/generated.scan"

    if ! cmp "$workdir/generated.scan" "$workdir/packaged.scan" || ! cmp "$workdir/packaged.scan" "$workdir/web.scan"; then
        echo "Error: kvdb contents mismatch for $tarname" >&2
        error=1
    fi
done

if [ $error -ne 0 ]; then
    echo "Error: failed validation" >&2
    exit 1
else
    echo "Validation successful" >&2
    exit 0
fi
