# Serializing types using Binable functors

For most OCaml types, the `Bin_prot` code is generated by adding an
annotation `[%%deriving bin_io]` to the type definition. In some
cases, when generating the code might be difficult, we can leverage an
existing type that already has associated serialization code. To
serialize a value, we convert a value of the type of interest to the
existing type, and use the existing serializer. To deserialize to the
type of interest, we deserialize to the existing type, and convert
that value to the type of interest.

For example:

```ocaml
module M1 = struct
  type t = string [@@deriving bin_io]
end

module M2 = struct
  type t = int

  include Binable.Of_binable (M1) (struct
                                     let to_binable n = Int.to_string n
									 let of_binable s = Int.of_string s
								   end)
end
```
To serialize and deserialize an integer of type `M2.t` involves conversions to or
from a string.

The module `M1` here defines a type `t` with no type parameters.
Besides `Of_binable`, `Binable` contains similar functors
`Of_binable1`, `Of_binable2`, and `Of_binable3`, where the number
indicates the number of type parameters to the type `t` contained in
the first functor argument.

There is also a functor `Bin_prot.Utils.Make_binable` that takes a
single argument, similar to the second argument of `Of_binable`, that
defines `to_binable` and `let_binable`, and also contains a module
`Binable` that contains a `Bin_prot`-serialized type:

```ocaml
module M3 = struct
  type t = int

  include Bin_prot.Utils.Make_binable (struct
                                        module Binable = M1
                                        let to_binable n = Int.to_string n
									    let of_binable s = Int.of_string s
                 					   end)
end
```

# Custom serializers

In some cases, instead of deriving code for `Bin_prot`, if you want
fine control of a type's serialization, or the serialization code
can't be generated, you can write your own code. Types may have a
combination of generated and custom code.

The signatures of the serialization code are:
```ocaml
(* determine the size of the buffer needed to hold a serialized value *)
val bin_size_t : Bin_spec.t Bin_prot.Size.sizer

(* write a serialized value to a buffer *)
val bin_write_t : Bin_spec.t Bin_prot.Write.writer

(* read a serialized value from a buffer *)
val bin_read_t : Bin_spec.t Bin_prot.Read.reader

(* a `vtag` reader *)
val __bin_read_t__ : (int -> Bin_spec.t) Bin_prot.Read.reader

(* derive a canonical shape for a value *)
val bin_shape_t : Bin_prot.Shape.t

(* containers for previous functions *)
val bin_writer_t : Bin_spec.t Bin_prot.Type_class.writer
val bin_reader_t : Bin_spec.t Bin_prot.Type_class.reader
val bin_t : Bin_spec.t Bin_prot.Type_class.t
```
If writing `Bin_prot`-compatible code in a language other than OCaml, that
code would have to replicate the serialization and deserialization strategy
used in the custom code.

# Versioned types

In Mina, except for types involved in client-to-daemon communication,
and some other isolated cases, serialized types are versioned.  Each
version of a type has its own serialization code.  The serialization
of a value with a versioned type always begins with a version number
as a serialized integer. When serializing a value, the version number
is pre-pended to the serialization of the underlying value.  When
deserializing, code can dispatch on the version number, and choose the
appropriate deserializer to obtain a value of the given version.
