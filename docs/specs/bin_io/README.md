# Serializing types using Binable functors

For most OCaml types, the `Bin_prot` code is generated by adding an annotation
`[%%deriving bin_io]` to the type definition. In some cases, when generating the
code might be difficult, we can leverage an existing type that already has
associated serialization code. To serialize a value, we convert a value of the
type of interest to the existing type, and use the existing serializer. To
deserialize to the type of interest, we deserialize to the existing type, and
convert that value to the type of interest.

For example:

```ocaml
module M1 = struct
  type t = string [@@deriving bin_io]
end

module M2 = struct
  type t = int

  include Binable.Of_binable (M1) (struct
                                     let to_binable n = Int.to_string n
									 let of_binable s = Int.of_string s
								   end)
end
```

To serialize and deserialize an integer of type `M2.t` involves conversions to
or from a string.

The module `M1` here defines a type `t` with no type parameters. Besides
`Of_binable`, `Binable` contains similar functors `Of_binable1`, `Of_binable2`,
and `Of_binable3`, where the number indicates the number of type parameters to
the type `t` contained in the first functor argument.

There is also a functor `Bin_prot.Utils.Make_binable` that takes a single
argument, similar to the second argument of `Of_binable`, that defines
`to_binable` and `let_binable`, and also contains a module `Binable` that
contains a `Bin_prot`-serialized type:

```ocaml
module M3 = struct
  type t = int

  include Bin_prot.Utils.Make_binable (struct
                                        module Binable = M1
                                        let to_binable n = Int.to_string n
									    let of_binable s = Int.of_string s
                 					   end)
end
```

# Custom serializers

In some cases, instead of deriving code for `Bin_prot`, if you want fine control
of a type's serialization, or the serialization code can't be generated, you can
write your own code. Types may have a combination of generated and custom code.

The signatures of the serialization code are:

```ocaml
(* determine the size of the buffer needed to hold a serialized value *)
val bin_size_t : Bin_spec.t Bin_prot.Size.sizer

(* write a serialized value to a buffer *)
val bin_write_t : Bin_spec.t Bin_prot.Write.writer

(* read a serialized value from a buffer *)
val bin_read_t : Bin_spec.t Bin_prot.Read.reader

(* a `vtag` reader *)
val __bin_read_t__ : (int -> Bin_spec.t) Bin_prot.Read.reader

(* derive a canonical shape for a value *)
val bin_shape_t : Bin_prot.Shape.t

(* containers for previous functions *)
val bin_writer_t : Bin_spec.t Bin_prot.Type_class.writer
val bin_reader_t : Bin_spec.t Bin_prot.Type_class.reader
val bin_t : Bin_spec.t Bin_prot.Type_class.t
```

If writing `Bin_prot`-compatible code in a language other than OCaml, that code
would have to replicate the serialization and deserialization strategy used in
the custom code.

# Versioned types

In Mina, except for types involved in client-to-daemon communication, and some
other isolated cases, serialized types are versioned. Each version of a type has
its own serialization code. The serialization of a value with a versioned type
always begins with a version number as a serialized integer. When serializing a
value, the version number is pre-pended to the serialization of the underlying
value. When deserializing, code can dispatch on the version number, and choose
the appropriate deserializer to obtain a value of the given version.
