import Page from '@reason/pages/Docs';
export default Page({title: "FAQ"});

# FAQ

## Testnet

#### Do I need any specific hardware?

Currently, a 4-core processor and 8 GB of RAM are the minimum requirements.  In the near future though, GPUs may be required.

#### What about software?

You can download all the software required to run a Coda node [here](./getting-started/#installation). Right now, we have builds that work on MacOS, as well as Debian and Ubuntu. You can also [build from source](https://github.com/codaprotocol/coda).

#### What can I do on the Coda network?

Any node can send and receive transactions on the Coda network. Additionally, any node can choose to be a "Node operator". Node operators play two specific roles:

1) Block Producer - this is analogous to being a Bitcoin "miner" or a "validator" in other  proof-of-stake networks. By staking coda, you can be selected to produce a block and win the block reward

2) Snark Worker - this job is what helps compress data in Coda's network. The snark worker nodes generate proofs of transactions, and the block producer buys these proofs on the network (we call it a "snarketplace" :)) - thus, the snark worker gets rewarded a bit of the block reward for their efforts.

#### What is the point of a testnet?

The Coda testnet's goal is to improve Coda's stability, improve the software through bug fixes and addressing user experience, and to test the economic incentive design in Coda. By participating in the testnet, you get to be the first participants in the Coda protocol, and help develop it from ground zero.

#### Where can I try out the testnet?

Head over to the [testnet landing page](/testnet.html) to learn more and get started.

#### My daemon crashed -- where should I share the error log?

First, check out [Github issues](https://github.com/codaprotocol/coda/issues) to see if this is a known issue. If the error you experienced is a new issue, file a Github issue with the appropriate tags (daemon, bug). Coda developers will triage the issue and fix it in a future sprint -- thanks for your help!

#### How can I report other issues / get in touch with the development team?

- The Coda community's live discussion channel is the [Discord server](https://bit.ly/CodaDiscord)
- You can also create Github issues: https://github.com/codaprotocol/coda/issues
- If you need to get in touch privately, you can email: contact@codaprotocol.org

#### Is there a block explorer?

Yes, check out these block explorers: 

https://codaexplorer.garethtdavies.com/

https://coda.bitfly.at/

## General Questions

#### What consensus algorithm does Coda use?

Coda's consensus mechanism is an implementation of Ouroboros Proof-of-Stake. Due to Coda's unique compressed blockchain, certain aspects of the algorithm have diverged from the Ouroboros papers, and the version Coda uses is affectionately called Codaboros. Stay tuned for more details on Codaboros and some technical writeups on its details and implementation.

#### How does Coda achieve scalability?

Coda achieves scalability through the use of recursive zk-SNARKs. By generating a proof that attests to the validity of historic blockchain states, Coda can keep the blockchain size fixed. This allows for increased throughput due to block size limits not being as taxing on the network, thereby increasing the scalability of the network.

#### What is the maximum transaction throughput?

Practically speaking, the limiting factor ends up being bandwidth, so it depends on the average quality of the internet connection among block producers. If the average connection is a symmetric 2MB/s, then it’s about 2000 tps.

#### Why did you develop a new protocol, rather than augmenting existing cryptocurrencies?

The reason for developing a new protocol instead of offering services to other blockchains is because adding SNARKs after the fact to a Layer 1 project is not trivial. Even basic operations need to be optimized for performance inside a SNARK, and existing implementations are not able to be retrofit as such. If we look at hashing functions for example, SHA256 (used by Bitcoin) or Keccak (used by Ethereum) are extremely expensive inside a SNARK circuit, but Poseidon (what Coda uses) is optimized for performance. This and many other technical considerations make it infeasible to easily add recursive SNARKs to existing Layer 1’s, without entirely overhauling the base protocol.

#### Will you require a trusted setup?

It very likely will. However, it is far less of an issue than it was a few years ago. The Zcash team has done a lot of great work on improving the process, and it’s now possible to perform a multi-party computation (MPC) ceremony with hundreds of participants. There would only be issues if every one of those participants were to collude - if just one participant is honest everything is fine, so there is a lot more confidence in the modern approach.

#### Does Coda support smart contracts? If so, what smart contracting languages does it support?

Coda does not support smart contracts currently. The development team is looking into smart contract models, and it is on the roadmap for future development.

#### Does Coda support shielded transactions, like in Zcash?

No, Coda does not natively implement privacy features at the moment. However, privacy is key consideration for cryptocurrencies, and is also on the development roadmap.
#
#### Can I run the Coda daemon as a service

[See here](/docs/node-operator#running-coda-as-a-service) for information about using launchd or systemd with coda.

## Block Producers

#### Can I run multiple Block Producers with the same Private Key? 

No. It is important to only run one Block Producer process against a particular private key. In the event the Coda daemon receives two different blocks from the same Block Producer, both blocks would be discarded. 

#### How can I verify that I am indeed producing blocks?

(Via the CLI): 
Execute `coda client status`

As output, you should see a block of text, there will be a line similar to this if your Block Producer is running: 
`Block producers running:        1 (B62qrPN5Y5yq8kGE3FbVK...)`

If your Block Producer has won a slot, you will see something like this: 
`Next block will be produced in:  in 17.52m`

(Via the Logs): 
The following text appears each time the daemon produces a block: 

`Producing new block with parent $breadcrumb`

#### I produced a block, why wasn't it selected for the *Canonical Chain*? 

Due to a property of the Codaboros consensus protocol, it's entirely possible that more than one block is produced in a particular slot. The network resolves the short-lived forks and will consolidate onto one block per slot by random selection.  

Below is a visualization of the Coda Blockchain:
![Visualization of the Coda Blockchain and its Singleton Forks](/static/img/faq/coda-singleton-forks.png)

## SNARKs and Snark Workers

#### If I run a Snark Worker, how do I get paid for my SNARKs that I generate?

Block producers (the validators who add new blocks to the blockchain) are required to buy SNARKs from the network (or from what we call the Snarketplace) and will pay out some of their block reward as fees to the snark workers who generated SNARKs. This creates a secondary incentive mechanism in the network to reward nodes that help compress transactions.

#### Is generating SNARKs similar to Proof-of-Work (PoW) mining?

No, they are different in several ways:

- SNARK work is deterministic, while PoW mining requires randomly calculating hashes to try and solve a puzzle. There is no luck element in SNARK work — if a snark worker wants to generate a SNARK of a transaction, they only need to generate the proof once. This means SNARK work is much less expensive and environmentally wasteful, as the compute is all spent towards a productive goal.
- There is no difficulty increase for SNARK work, as there is with PoW mining. In fact, as SNARK constructions, and proof generation times improve, the difficulty may actually decrease.
- SNARK work is not directly involved in consensus. Snark workers play no role in determining the next state of the blockchain. Their role is to simply generate SNARKs of transactions observed in the network
- As a snark worker, there is no requirement for uptime. PoW miners need to run their rigs non-stop to ensure they don't miss out on a potential block. Snark workers can come online and offline as they please — it is more like Uber, where there will always be work to be done, and it is nobody needs to say head of of time when they want to work.

#### Why have my SNARKs not been included? (A.K.A. How should I price my SNARKs?)

Even though your SNARK Worker might be producing SNARKs at a breakneck pace, if someone else produces a cheaper proof for a particular job you have already completed, their SNARK would be preferred due to its lower fee. 

Pricing your SNARKs is a delicate balance between the cost of compute, the market environment (demand for SNARKs), your SNARK throughput, and the speed at which each of your SNARK Worker processes can produce SNARKs. Sometimes, it might even be economically prudent to turn off your SNARK Worker altogether until the market improves. 

#### Will Snark Workers require more storage and computing power over time? What about compared to Coda full nodes?

Snark workers will not need more storage or computing power over time. Snark workers simply query the mempool for pending transactions requiring Snark proofs, and then generate said proof -- this does not require syncing historical data. In addition, the underlying proving cost of Snark work doesn’t get more expensive with time.

If we are comparing Snark worker nodes with full nodes on Coda, then yes Snark workers will benefit from specialized hardware as generating SNARK proofs is currently compute intensive. Again, however, with the explosion of SNARK research, this is likely to change and become more accessible to consumer hardware.

#### What is the difference between a SNARK, a SNARK proof, and snark work?

SNARKs are a very overloaded term currently — when you read **SNARK**, it could be referring to the concept of succinct non-interactive proof systems (eg. SNARKs vs Bulletproofs), the specific technical implementation of the proof system (eg. the construction, the circuit, or the prover), or the individual instance of the proof itself (eg. the blockchain SNARK). 

When we speak about it, we will try to adhere to using:

- SNARK: as the general concept of succinct, non-interactive zero-knowledge proofs
- SNARK circuit: the specific circuit and prover, as pertaining to an app
- SNARK proof: an individual proof that is generated by a SNARK prover
- snark work: a Coda protocol data structure that is a wrapper around one or two SNARK proofs and a price to be paid to the snark worker that generated the proof(s). This is made unforgeable by a Signature of Knowledge scheme that will be detailed in another section.

#### Is there any concern about a single large snark worker [dumping](https://en.wikipedia.org/wiki/Dumping_(pricing_policy)) work in the snarketplace, and then raising prices after monopolizing the market?

In economics, there is a pricing strategy called predatory pricing (or dumping) where one supplier of a product seeks to exhaust competing suppliers in the market by undercutting the market price. The supplier prices their goods much cheaper than the market rate, in order to drive out competitors, even if it means incurring short-term losses. Once the market has been cleared, the dominant supplier then increases prices [above competitive market rates](https://en.wikipedia.org/wiki/Supracompetitive_pricing), as competition has been extinguished.

However, this strategy is only effective in markets where there are high barriers to entry. Meaning, competitors who were crowded out in the predation stage are unable to rejoin the market. 

This is not the case for snark work, as the barriers to entry are low. Anyone who has spare compute can join the snarketplace and produce as little as one snark work, and profit on that unit of work. The only barrier to entry is the initial capital expense on hardware, but we anticipate hardware requirements to be low, such that users with spare equipment can come online and participate. If any snark worker succeeds in driving out the market and increases prices, it is anticipated that newcomers would reappear and drive prices back down.

#### Does speed of producing snarks matter? If my computer is slower, will I be at a disadvantage?

No, provided that the snark work produced is still required by block producers, it doesn't matter who produced it first — only the price matters in the block producers' eyes. The caveat here is that earlier inclusion into the snark mempool is obviously beneficial, as block producers are likely to "see" the work earlier.

One could however envision a scenario where a set of snark workers are favored because they produced the most number of snark works that are profitable, and buying proofs from as few entities as possible would allow for more transactions to be included in any block.

There is also a threshold at which time becomes a factor, but this would only apply to very underpowered devices. We will follow up with detailed benchmarks, when we have run more tests.

#### Will a full node need to store all intermediate SNARK proofs? Eg. Will the storage requirements grow linearly with blocks?

Nope -- when a new block is generated, Coda computes the proof recursively over the prior proof and the new block. This is the advantage of recursive composition -- at any given time, nodes only need to store the most recent proof. Intermediate proofs are not needed. See this talk for more clarity on how this architecture emerged: https://www.youtube.com/watch?v=eWVGATxEB6M

#### How do you control or limit the number of cores Snark Workers use?

You can use the `-snark-worker-parallelism` flag when starting up `coda daemon`.

