package hardfork

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/MinaProtocol/mina/src/app/hardfork_test/src/internal/client"
)

type HashAndS3 struct {
	S3DataHash string `json:"s3_data_hash"`
	Hash       string `json:"hash"`
}

type RuntimeGenesisLedgerHashes struct {
	EpochData struct {
		Staking HashAndS3 `json:"staking"`
		Next    HashAndS3 `json:"next"`
	} `json:"epoch_data"`
	Ledger HashAndS3 `json:"ledger"`
}

func (t *HardforkTest) ValidateRuntimeGenesisLedgerHashes(
	analysis *BlockAnalysisResult,
	ledgerHashesFile string,
) error {

	t.Logger.Info("Validating ledger hashes file generated by runtime-genesis-ledger")

	// Calculate slot_tx_end_epoch
	// WARN: 48 as specififed by mina-local-network.sh, keep it in sync with mina-local-network!
	slotTxEndEpoch := analysis.Consensus.LastBlockBeforeTxEnd.Slot / 48

	// Find expected staking and next hashes
	expectedStakingHash, err := t.FindStakingHash(slotTxEndEpoch, analysis.GenesisBlock, analysis.SnarkedHashByEpoch)
	if err != nil {
		return fmt.Errorf("failed to find staking hash: %w", err)
	}

	expectedNextHash, err := t.FindStakingHash(slotTxEndEpoch+1, analysis.GenesisBlock, analysis.SnarkedHashByEpoch)

	if err != nil {
		return fmt.Errorf("failed to find next hash: %w", err)
	}

	// Read prefork hashes from file
	ledgerHashesBytes, err := os.ReadFile(ledgerHashesFile)
	if err != nil {
		return fmt.Errorf("failed to read ledger hashes file: %w", err)
	}

	var hashes RuntimeGenesisLedgerHashes
	dec := json.NewDecoder(bytes.NewReader(ledgerHashesBytes))
	dec.DisallowUnknownFields()

	if err := dec.Decode(&hashes); err != nil {
		return fmt.Errorf("failed to unmarshal ledger hashes file: %w", err)
	}

	if hashes.EpochData.Staking.Hash != expectedStakingHash {
		return fmt.Errorf("Expected epoch_data.staking.hash `%s`, got `%s`", expectedStakingHash, hashes.EpochData.Staking.Hash)
	}

	if hashes.EpochData.Next.Hash != expectedNextHash {
		return fmt.Errorf("Expected epoch_data.next.hash `%s`, got `%s`", expectedNextHash, hashes.EpochData.Next.Hash)
	}

	if hashes.Ledger.Hash != analysis.Consensus.LastBlockBeforeTxEnd.StagedHash {
		return fmt.Errorf("Expected ledger.hash `%s`, got `%s`", analysis.Consensus.LastBlockBeforeTxEnd.StagedHash, hashes.Ledger.Hash)
	}

	t.Logger.Info("Ledger hashes file validated successfully")
	return nil
}

type EpochDataPrepatch struct {
	Seed     string `json:"seed"`
	Accounts any    `json:"accounts"`
}

type LegacyPrepatchForkConfigView struct {
	Proof struct {
		Fork struct {
			BlockChainLength       int    `json:"blockchain_length"`
			GlobalSlotSinceGenesis int    `json:"global_slot_since_genesis"`
			StateHash              string `json:"state_hash"`
		} `json:"fork"`
	} `json:"proof"`
	EpochData struct {
		Staking EpochDataPrepatch `json:"staking"`
		Next    EpochDataPrepatch `json:"next"`
	} `json:"epoch_data"`
	Ledger struct {
		Hash             string `json:"hash"`
		Accounts         any    `json:"accounts"`
		AddGenesisWinner bool   `json:"add_genesis_winner"`
	} `json:"ledger"`
}

func (t *HardforkTest) ValidateLegacyPrepatchForkConfig(lastBlockBeforeTxEnd client.BlockData, config LegacyPrepatchForkConfigView) error {

	t.Logger.Info("Validating legacy prepatch fork config")

	if config.Proof.Fork.BlockChainLength != lastBlockBeforeTxEnd.BlockHeight {
		return fmt.Errorf("Expected proof.fork.blockchain_length to be %d, got %d", lastBlockBeforeTxEnd.BlockHeight, config.Proof.Fork.BlockChainLength)
	}

	if config.Proof.Fork.GlobalSlotSinceGenesis != lastBlockBeforeTxEnd.Slot {
		return fmt.Errorf("Expected proof.fork.global_slot_since_genesis to be %d, got %d", lastBlockBeforeTxEnd.Slot, config.Proof.Fork.GlobalSlotSinceGenesis)
	}

	if config.Proof.Fork.StateHash != lastBlockBeforeTxEnd.StateHash {
		return fmt.Errorf("Expected proof.fork.state_hash to be `%s`, got `%s`", lastBlockBeforeTxEnd.StateHash, config.Proof.Fork.StateHash)
	}

	if config.EpochData.Staking.Seed != lastBlockBeforeTxEnd.CurEpochSeed {
		return fmt.Errorf("Expected proof.epoch_data.staking.seed to be `%s`, got `%s`", lastBlockBeforeTxEnd.CurEpochSeed, config.EpochData.Staking.Seed)
	}

	if config.EpochData.Next.Seed != lastBlockBeforeTxEnd.NextEpochSeed {
		return fmt.Errorf("Expected proof.epoch_data.next.seed to be `%s`, got `%s`", lastBlockBeforeTxEnd.NextEpochSeed, config.EpochData.Next.Seed)
	}

	if config.Ledger.Hash != lastBlockBeforeTxEnd.StagedHash {
		return fmt.Errorf("Expected ledger.hash to be `%s`, got `%s`", lastBlockBeforeTxEnd.StagedHash, config.Ledger.Hash)
	}

	if config.Ledger.AddGenesisWinner != false {
		return fmt.Errorf("Expected ledger.add_genesis_winner to be false, got true")
	}

	t.Logger.Info("Legacy prepatch fork config validated successfully")
	return nil
}

type EpochData struct {
	Hash       string `json:"hash"`
	S3DataHash string `json:"s3_data_hash"`
	Seed       string `json:"seed"`
}

type FinalForkConfigView struct {
	Proof struct {
		Fork struct {
			BlockChainLength       int    `json:"blockchain_length"`
			GlobalSlotSinceGenesis int64  `json:"global_slot_since_genesis"`
			StateHash              string `json:"state_hash"`
		} `json:"fork"`
	} `json:"proof"`
	EpochData struct {
		Staking EpochData `json:"staking"`
		Next    EpochData `json:"next"`
	} `json:"epoch_data"`
	Genesis struct {
		GenesisStateTimeStamp time.Time `json:"genesis_state_timestamp"`
	}
	Ledger struct {
		Hash             string `json:"hash"`
		S3DataHash       string `json:"s3_data_hash"`
		AddGenesisWinner bool   `json:"add_genesis_winner"`
	} `json:"ledger"`
}

func (t *HardforkTest) ValidateFinalForkConfig(lastBlockBeforeTxEnd client.BlockData, config FinalForkConfigView, forkGenesisTs, mainGenesisTs int64) error {

	t.Logger.Info("Validating final fork config")
	// Calculate expected genesis slot
	expectedGenesisSlot := (forkGenesisTs - mainGenesisTs) / int64(t.Config.MainSlot)

	if config.Proof.Fork.BlockChainLength != lastBlockBeforeTxEnd.BlockHeight {
		return fmt.Errorf("Expected proof.fork.blockchain_length to be %d, got %d", lastBlockBeforeTxEnd.BlockHeight, config.Proof.Fork.BlockChainLength)
	}

	if config.Proof.Fork.GlobalSlotSinceGenesis != expectedGenesisSlot {
		return fmt.Errorf("Expected proof.fork.global_slot_since_genesis to be %d, got %d", expectedGenesisSlot, config.Proof.Fork.GlobalSlotSinceGenesis)
	}

	if config.Proof.Fork.StateHash != lastBlockBeforeTxEnd.StateHash {
		return fmt.Errorf("Expected proof.fork.state_hash to be `%s`, got `%s`", lastBlockBeforeTxEnd.StateHash, config.Proof.Fork.StateHash)
	}

	if config.Genesis.GenesisStateTimeStamp.Unix() != forkGenesisTs {
		return fmt.Errorf("Expected genesis.genesis_state_timestamp to be `%d`(unix timestamp), got `%s`(RFC3339)", forkGenesisTs, config.Genesis.GenesisStateTimeStamp.Format(time.RFC3339))
	}

	t.Logger.Info("Final fork config validated successfully")
	return nil
}
