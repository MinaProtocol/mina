package config

import (
	"fmt"
	"os"
	"time"
)

// Config represents the application configuration parameters
type Config struct {
	// Executable paths
	MainMinaExe              string
	MainRuntimeGenesisLedger string
	ForkMinaExe              string
	ForkRuntimeGenesisLedger string

	// Root folder for everything generated by `mina-local-network.sh`
	Root string

	SeedStartPort        int
	SnarkCoordinatorPort int
	WhaleStartPort       int
	FishStartPort        int
	NodeStartPort        int

	// Slot configuration
	SlotTxEnd    int
	SlotChainEnd int

	// Best chain query configuration, number of slots
	BestChainQueryFrom int

	// Slot duration in seconds
	MainSlot int
	ForkSlot int

	MainDelayMin int
	HfSlotDelta  int

	// Configuration for network sizes
	NumWhales int
	NumFish   int
	NumNodes  int

	// Interval of sending payments in second
	PaymentInterval int

	// Script directory path
	ScriptDir string

	// Shutdown timeout in minutes before forcing kill
	ShutdownTimeoutMinutes int

	// Timing configuration (in seconds)
	PollingIntervalSeconds        int // Interval for polling height checks
	ForkConfigRetryDelaySeconds   int // Delay between fork config fetch retries
	ForkConfigMaxRetries          int // Max number of retries for fork config fetch
	NoNewBlocksWaitSeconds        int // Wait time to verify no new blocks after chain end
	UserCommandCheckMaxIterations int // Max iterations to check for user commands in blocks
	ForkEarliestBlockMaxRetries   int // Max retries to wait for earliest block in fork network
	HTTPClientTimeoutSeconds      int // HTTP client timeout for GraphQL requests
	ClientMaxRetries              int // Max number of retries for client requests

	ForkMethod ForkMethod
}

// DefaultConfig returns the default configuration with values
// matching those in the original shell script
func DefaultConfig() *Config {
	return &Config{
		SlotTxEnd:                     30,
		SlotChainEnd:                  38, // SlotTxEnd + 8
		BestChainQueryFrom:            25,
		MainSlot:                      30,
		ForkSlot:                      30,
		MainDelayMin:                  7,
		HfSlotDelta:                   30, // if this is too small and fork network is spawned after fork genesis, it'll fail to create any block
		NumWhales:                     2,
		NumFish:                       1,
		NumNodes:                      0,
		PaymentInterval:               20,
		ShutdownTimeoutMinutes:        10,
		PollingIntervalSeconds:        8,
		ForkConfigRetryDelaySeconds:   60,
		ForkConfigMaxRetries:          15,
		NoNewBlocksWaitSeconds:        300, // 5 minutes
		UserCommandCheckMaxIterations: 10,
		ForkEarliestBlockMaxRetries:   10,
		HTTPClientTimeoutSeconds:      600,
		// ^ fork config take really long time to complete (2-3 minutes)
		ClientMaxRetries: 5,

		SeedStartPort:        3000,
		SnarkCoordinatorPort: 7000,
		WhaleStartPort:       4000,
		FishStartPort:        5000,
		NodeStartPort:        6000,

		ForkMethod: Legacy,
	}
}

func (c *Config) ForkGenesisTsGivenMainGenesisTs(mainGenesisTs int64) int64 {
	forkGenesisSlot := c.SlotChainEnd + c.HfSlotDelta
	return mainGenesisTs + int64(forkGenesisSlot*c.MainSlot)
}

// Validate checks if the configuration is valid
func (c *Config) Validate() error {
	// Check if required paths are specified
	if c.MainMinaExe == "" {
		return ErrMissingMainMinaExe
	}
	if c.MainRuntimeGenesisLedger == "" {
		return ErrMissingMainRuntimeGenesisLedger
	}
	if c.ForkMinaExe == "" {
		return ErrMissingForkMinaExe
	}
	if c.ForkRuntimeGenesisLedger == "" {
		return ErrMissingForkRuntimeGenesisLedger
	}
	if c.ScriptDir == "" {
		return ErrMissingScriptDir
	}
	if c.Root == "" {
		return ErrMissingRoot
	}

	// Check if executables exist and have proper permissions
	if err := validateExecutable(c.MainMinaExe); err != nil {
		return FileValidationError(c.MainMinaExe, err)
	}
	if err := validateExecutable(c.MainRuntimeGenesisLedger); err != nil {
		return FileValidationError(c.MainRuntimeGenesisLedger, err)
	}
	if err := validateExecutable(c.ForkMinaExe); err != nil {
		return FileValidationError(c.ForkMinaExe, err)
	}
	if err := validateExecutable(c.ForkRuntimeGenesisLedger); err != nil {
		return FileValidationError(c.ForkRuntimeGenesisLedger, err)
	}

	if err := validateScriptDir(c.ScriptDir); err != nil {
		return FileValidationError(c.ScriptDir, err)
	}

	return nil
}

// FormatTimestamp formats a UNIX timestamp into the format used by the shell script
func FormatTimestamp(unixTs int64) string {
	t := time.Unix(unixTs, 0).UTC()
	return t.Format(time.RFC3339)
}

// validateExecutable checks if a file exists and has executable permissions
func validateExecutable(path string) error {
	// Check if file exists
	info, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return ErrFileNotExists
		}
		return err
	}

	// Check if it's a regular file (not a directory)
	if info.IsDir() {
		return fmt.Errorf("path is a directory, not an executable file")
	}

	// Check executable permission - mode & 0111 is checking for any execution bit (user, group, or others)
	if info.Mode().Perm()&0111 == 0 {
		return ErrNotExecutable
	}

	return nil
}

func validateScriptDir(path string) error {
	info, err := os.Stat(path)
	if err != nil {
		return err
	}
	if !info.IsDir() {
		return ErrNotADir
	}

	return nil
}
