(** {1 Step Verifier - Verification Logic for Step Circuits}

    This module provides the verification logic used within step circuits
    to verify wrap proofs and finalize deferred computations.

    {2 Overview}

    The step verifier is responsible for:
    1. Finalizing "other proofs" - completing deferred scalar-field checks
    2. Incrementally verifying wrap proofs (group operations + IPA)
    3. Hashing messages for the next step/wrap proofs
    4. Managing the Fiat-Shamir transcript (sponge)

    {2 Context: Step Circuit Verification}

    When a step circuit verifies a wrap proof:
    - Group operations (curve additions, scalar mults) are performed directly
    - Scalar-field operations in Tock's scalar field are native (efficient)
    - The IPA is verified incrementally, producing new challenges

    {2 Key Functions}

    - {!val:finalize_other_proof}: Completes deferred scalar-field checks
      from a previous wrap proof's [Deferred_values]
    - {!val:verify}: Full incremental verification of a wrap proof
    - {!val:hash_messages_for_next_step_proof}: Hashes accumulated data for
      the next recursion layer

    {2 Challenge Generation (Fiat-Shamir)}

    Challenges are generated by:
    1. Absorbing commitments/values into the sponge
    2. Squeezing 128-bit challenges from the sponge
    3. Scalar challenges use the endomorphism for efficiency

    {2 Implementation Notes for Rust Port}

    - Uses [Impl] (Step implementation) for field operations
    - [Scalar_challenge] uses endomorphism-based encoding
    - [Other_field] refers to Tock's base field (= Tick's scalar field)
    - [Shifted_value.Type1] handles field element representation

    @see <../GLOSSARY.md> for terminology definitions
    @see {!Step_main} for the step circuit entry point
    @see {!Wrap_verifier} for the corresponding wrap-side verifier
*)

module Impl := Step_main_inputs.Impl

module Challenge : module type of Import.Challenge.Make (Impl)

module Digest : module type of Import.Digest.Make (Impl)

module Scalar_challenge :
    module type of
      Scalar_challenge.Make (Impl) (Step_main_inputs.Inner_curve) (Challenge)
        (Endo.Step_inner_curve)

module Pseudo = Pseudo.Step

module Inner_curve : sig
  type t = Step_main_inputs.Inner_curve.t

  val typ : (t, Step_main_inputs.Inner_curve.Constant.t) Impl.Typ.t
end

module Other_field : sig
  type t = Impl.Other_field.t

  val size_in_bits : int

  val typ : (t, Impls.Step.Other_field.Constant.t) Impls.Step.Typ.t
end

(** [assert_n_bits ~n x] asserts that field element [x] fits in [n] bits.

    Uses scalar challenge conversion which has the side effect of checking
    bit length.
*)
val assert_n_bits : n:int -> Impl.Field.t -> unit

(** [finalize_other_proof] completes deferred scalar-field checks.

    When a step circuit partially verifies a wrap proof, certain scalar
    operations are deferred because they would be non-native. This function
    performs those checks.

    {3 Process}

    1. Reconstructs the sponge state from [sponge_digest_before_evaluations]
    2. Absorbs polynomial evaluations
    3. Squeezes the IPA challenges
    4. Computes the challenge polynomial evaluation
    5. Verifies [combined_inner_product] and [b] values

    @param step_domains Either known domains or side-loaded (for dynamic vks)
    @param zk_rows Number of zero-knowledge rows in the circuit
    @param sponge The Fiat-Shamir sponge (transcript)
    @param prev_challenges Old bulletproof challenges to verify against
    @param deferred_values The values deferred from partial verification
    @param evals Polynomial evaluations at zeta and zeta*omega

    @return Tuple of:
    - Boolean indicating if finalization succeeded
    - Vector of new bulletproof challenges

    BEWARE: If [should_finalize] is false, the boolean may be false without
    indicating an error.
*)
val finalize_other_proof :
     (module Pickles_types.Nat.Add.Intf with type n = 'b)
  -> step_domains:
       [ `Known of (Import.Domains.t, 'branches) Pickles_types.Vector.t
       | `Side_loaded ]
  -> zk_rows:int
  -> sponge:Step_main_inputs.Sponge.t
  -> prev_challenges:
       ((Impl.Field.t, 'a) Pickles_types.Vector.t, 'b) Pickles_types.Vector.t
  -> ( Impl.Field.t
     , Impl.Field.t Import.Scalar_challenge.t
     , Impl.Field.t Pickles_types.Shifted_value.Type1.t
     , ( Impl.Field.t Pickles_types.Shifted_value.Type1.t
       , Impl.Boolean.var )
       Composition_types.Opt.t
     , ( Impl.Field.t Import.Scalar_challenge.t
       , Impl.Boolean.var )
       Composition_types.Opt.t
     , ( Impl.Field.t Import.Scalar_challenge.t Import.Bulletproof_challenge.t
       , 'c )
       Pickles_types.Vector.t
     , Import.Branch_data.Checked.Step.t
     , Impl.Boolean.var )
     Import.Types.Wrap.Proof_state.Deferred_values.In_circuit.t
  -> ( Impl.Field.t
     , Impl.Field.t Core_kernel.Array.t
     , Impl.Boolean.var )
     Pickles_types.Plonk_types.All_evals.In_circuit.t
  -> Impl.Boolean.var * (Impl.Field.t, 'c) Pickles_types.Vector.t

val hash_messages_for_next_step_proof :
     index:
       Step_main_inputs.Inner_curve.t array
       Pickles_types.Plonk_verification_key_evals.t
  -> ('s -> Impl.Field.t array)
  -> (   ( 'a
         , 's
         , (Inner_curve.t, 'b) Pickles_types.Vector.t
         , ( (Impl.Field.t, 'c) Pickles_types.Vector.t
           , 'b )
           Pickles_types.Vector.t )
         Import.Types.Step.Proof_state.Messages_for_next_step_proof.t
      -> Impl.Field.t )
     Core_kernel.Staged.t

val hash_messages_for_next_step_proof_opt :
     index:
       Step_main_inputs.Inner_curve.t array
       Pickles_types.Plonk_verification_key_evals.t
  -> ('s -> Impl.Field.t array)
  -> Step_main_inputs.Sponge.t
     * (   ( 'a
           , 's
           , (Inner_curve.t, 'b) Pickles_types.Vector.t
           , ( (Impl.Field.t, 'c) Pickles_types.Vector.t
             , 'b )
             Pickles_types.Vector.t )
           Import.Types.Step.Proof_state.Messages_for_next_step_proof.t
        -> proofs_verified_mask:
             ( Impl.Field.t Snarky_backendless.Boolean.t
             , 'b )
             Pickles_types.Vector.t
        -> Impl.Field.t )
       Core_kernel.Staged.t

(** [verify] performs full incremental verification of a wrap proof.

    This is the main verification function called by step circuits. It
    verifies a wrap proof using the provided verification key and
    accumulates bulletproof challenges.

    {3 Verification Steps}

    1. Compute public input commitment from the statement
    2. Reconstruct Fiat-Shamir transcript from proof messages
    3. Verify PLONK constraints via linearization check
    4. Run IPA/bulletproof verification incrementally
    5. Check all challenges match the statement

    {3 Key Parameters}

    @param proofs_verified Module witnessing the proof count
    @param is_base_case If true, skip verification (for genesis/base proofs)
    @param sg_old Old challenge polynomial commitments (accumulators)
    @param sponge_after_index Sponge state after absorbing verification key
    @param lookup_parameters Parameters for lookup arguments (if enabled)
    @param feature_flags Which optional PLONK features are enabled
    @param proof The wrap proof to verify
    @param srs Structured Reference String
    @param wrap_domain Either known or side-loaded domain configuration
    @param wrap_verification_key Polynomial commitments from wrap circuit
    @param statement The wrap statement (public input/output)
    @param unfinalized The unfinalized proof data to populate

    @return Boolean indicating verification success

    Note: The [unfinalized] parameter is populated with deferred values
    that the wrap circuit will later finalize.
*)
val verify :
     proofs_verified:(module Pickles_types.Nat.Add.Intf with type n = 'a)
  -> is_base_case:Impl.Boolean.var
  -> sg_old:(Impls.Step.Field.t Tuple_lib.Double.t, 'a) Pickles_types.Vector.t
  -> sponge_after_index:Step_main_inputs.Sponge.t
  -> lookup_parameters:
       ( Limb_vector.Challenge.Constant.t
       , Impl.Field.t
       , 'b
       , Impl.Field.t Pickles_types.Shifted_value.Type1.t )
       Composition_types.Wrap.Lookup_parameters.t
       (* lookup arguments parameters *)
  -> feature_flags:Pickles_types.Opt.Flag.t Pickles_types.Plonk_types.Features.t
  -> proof:Wrap_proof.Checked.t
  -> srs:Kimchi_bindings.Protocol.SRS.Fq.t
  -> wrap_domain:
       [ `Known of Import.Domain.t
       | `Side_loaded of
         Composition_types.Branch_data.Proofs_verified.One_hot.Checked.t ]
  -> wrap_verification_key:
       Step_main_inputs.Inner_curve.t array
       Pickles_types.Plonk_verification_key_evals.t
  -> ( Impl.Field.t
     , Impl.Field.t Composition_types.Scalar_challenge.t
     , Impl.Field.t Pickles_types.Shifted_value.Type1.t
     , ( Impl.Field.t Pickles_types.Shifted_value.Type1.t
       , Impl.Boolean.var )
       Pickles_types.Opt.t
     , ( Impl.Field.t Composition_types.Scalar_challenge.t
       , Impl.Field.t Snarky_backendless.Boolean.t )
       Pickles_types.Opt.t
     , Impl.Boolean.var
     , Impl.Field.t
     , Impl.Field.t
     , Impl.Field.t
     , ( Impl.Field.t Kimchi_backend_common.Scalar_challenge.t
         Composition_types.Bulletproof_challenge.t
       , Pickles_types.Nat.z Backend.Tick.Rounds.plus_n )
       Pickles_types.Vector.t
     , Composition_types.Branch_data.Checked.Step.t )
     Import.Types.Wrap.Statement.In_circuit.t
     (* statement *)
  -> Impls.Step.unfinalized_proof_var (* unfinalized *)
  -> Impl.Boolean.var

module For_tests_only : sig
  type field := Impl.Field.t

  val side_loaded_domain :
       log2_size:field
    -> < generator : field
       ; log2_size : field
       ; shifts : field Pickles_types.Plonk_types.Shifts.t
       ; vanishing_polynomial : field -> field >
end
