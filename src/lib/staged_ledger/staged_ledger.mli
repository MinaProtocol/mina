open Core_kernel
open Async_kernel
open Mina_base
open Mina_transaction
open Signature_lib
module Ledger = Mina_ledger.Ledger

type t

module Scan_state : sig
  [%%versioned:
  module Stable : sig
    [@@@no_toplevel_latest_type]

    module V2 : sig
      type t

      val hash : t -> Staged_ledger_hash.Aux_hash.t
    end
  end]

  type t

  module Job_view : sig
    type t [@@deriving sexp, to_yojson]
  end

  (** Space available and number of jobs required to enqueue transactions in the
      scan state.

      first = space on the latest tree and number of proofs required
      second = If the space on the latest tree is less than max size (defined at
      compile time) then remaining number of slots for a new tree and the
      corresponding number of proofs required *)
  module Space_partition : sig
    type t = { first : int * int; second : (int * int) option }
    [@@deriving sexp]
  end

  val empty :
    constraint_constants:Genesis_constants.Constraint_constants.t -> unit -> t

  (** Statements of the required snark work *)
  val snark_job_list_json : t -> string

  (** Statements of all the pending work. Fails if there are any invalid
      statements in the scan state [t] *)
  val all_work_statements_exn : t -> Transaction_snark_work.Statement.t list

  (** Hashes of the protocol states required for proving pending transactions *)
  val required_state_hashes : t -> State_hash.Set.t

  (** Validate protocol states required for proving the transactions. Returns an
      association list of state_hash and the corresponding state*)
  val check_required_protocol_states :
       t
    -> protocol_states:
         Mina_state.Protocol_state.value State_hash.With_state_hashes.t list
    -> Mina_state.Protocol_state.value State_hash.With_state_hashes.t list
       Or_error.t

  (** Apply transactions corresponding to the last emitted proof based on the
      two-pass system to get snarked ledger
      - first pass includes legacy transactions and zkapp payments
      - second pass includes account updates. This ignores any account updates
      if a blocks transactions were split among two trees.
    *)
  val get_snarked_ledger_sync :
       ledger:Ledger.t
    -> get_protocol_state:
         (State_hash.t -> Mina_state.Protocol_state.Value.t Or_error.t)
    -> apply_first_pass:
         (   global_slot:Mina_numbers.Global_slot_since_genesis.t
          -> txn_state_view:Mina_base.Zkapp_precondition.Protocol_state.View.t
          -> Ledger.t
          -> Transaction.t
          -> Ledger.Transaction_partially_applied.t Or_error.t )
    -> apply_second_pass:
         (   Ledger.t
          -> Ledger.Transaction_partially_applied.t
          -> Mina_transaction_logic.Transaction_applied.t Or_error.t )
    -> apply_first_pass_sparse_ledger:
         (   global_slot:Mina_numbers.Global_slot_since_genesis.t
          -> txn_state_view:Mina_base.Zkapp_precondition.Protocol_state.View.t
          -> Mina_ledger.Sparse_ledger.t
          -> Mina_transaction.Transaction.t
          -> Mina_ledger.Sparse_ledger.T.Transaction_partially_applied.t
             Or_error.t )
    -> signature_kind:Mina_signature_kind.t
    -> t
    -> unit Or_error.t

  (** Apply transactions corresponding to the last emitted proof based on the
      two-pass system to get snarked ledger
      - first pass includes legacy transactions and zkapp payments
      - second pass includes account updates. This ignores any account updates
        if a blocks transactions were split among two trees.
    *)
  val get_snarked_ledger_async :
       ?async_batch_size:int
    -> ledger:Ledger.t
    -> get_protocol_state:
         (State_hash.t -> Mina_state.Protocol_state.Value.t Or_error.t)
    -> apply_first_pass:
         (   global_slot:Mina_numbers.Global_slot_since_genesis.t
          -> txn_state_view:Mina_base.Zkapp_precondition.Protocol_state.View.t
          -> Ledger.t
          -> Transaction.t
          -> Ledger.Transaction_partially_applied.t Or_error.t )
    -> apply_second_pass:
         (   Ledger.t
          -> Ledger.Transaction_partially_applied.t
          -> Mina_transaction_logic.Transaction_applied.t Or_error.t )
    -> apply_first_pass_sparse_ledger:
         (   global_slot:Mina_numbers.Global_slot_since_genesis.t
          -> txn_state_view:Mina_base.Zkapp_precondition.Protocol_state.View.t
          -> Mina_ledger.Sparse_ledger.t
          -> Mina_transaction.Transaction.t
          -> Mina_ledger.Sparse_ledger.T.Transaction_partially_applied.t
             Or_error.t )
    -> signature_kind:Mina_signature_kind.t
    -> t
    -> unit Deferred.Or_error.t

  val write_all_proofs_to_disk :
       signature_kind:Mina_signature_kind.t
    -> proof_cache_db:Proof_cache_tag.cache_db
    -> Stable.Latest.t
    -> t

  val read_all_proofs_from_disk : t -> Stable.Latest.t
end

module Pre_diff_info : Pre_diff_info.S

module Staged_ledger_error : sig
  type t =
    | Non_zero_fee_excess of
        Scan_state.Space_partition.t * Transaction.t With_status.t list
    | Invalid_proofs of
        ( Ledger_proof.t
        * Transaction_snark.Statement.t
        * Mina_base.Sok_message.t )
        list
        * Error.t
    | Couldn't_reach_verifier of Error.t
    | Pre_diff of Pre_diff_info.Error.t
    | Insufficient_work of string
    | Mismatched_statuses of Transaction.t With_status.t * Transaction_status.t
    | Invalid_public_key of Public_key.Compressed.t
    | ZkApps_exceed_limit of int * int
    | Unexpected of Error.t
  [@@deriving sexp_of]

  val to_string : t -> string

  val to_error : t -> Error.t
end

val ledger : t -> Ledger.t

val scan_state : t -> Scan_state.t

val pending_coinbase_collection : t -> Pending_coinbase.t

val create_exn :
     constraint_constants:Genesis_constants.Constraint_constants.t
  -> ledger:Ledger.t
  -> t

val replace_ledger_exn : t -> Ledger.t -> t

val copy : t -> t

val hash : t -> Staged_ledger_hash.t

type transaction_pool_proxy = Check_commands.transaction_pool_proxy

val apply :
     ?skip_verification:[ `Proofs | `All ]
  -> constraint_constants:Genesis_constants.Constraint_constants.t
  -> global_slot:Mina_numbers.Global_slot_since_genesis.t
  -> get_completed_work:
       (   Transaction_snark_work.Statement.t
        -> Transaction_snark_work.Checked.t option )
  -> logger:Logger.t
  -> verifier:Verifier.t
  -> current_state_view:Zkapp_precondition.Protocol_state.View.t
  -> state_and_body_hash:State_hash.t * State_body_hash.t
  -> coinbase_receiver:Public_key.Compressed.t
  -> supercharge_coinbase:bool
  -> zkapp_cmd_limit_hardcap:int
  -> signature_kind:Mina_signature_kind.t
  -> ?transaction_pool_proxy:Check_commands.transaction_pool_proxy
  -> t
  -> Staged_ledger_diff.t
  -> ( [ `Ledger_proof of Ledger_proof.Cached.t option ]
       * [ `Staged_ledger of t ]
       * [ `Accounts_created of Account_id.t list ]
       * [ `Pending_coinbase_update of bool * Pending_coinbase.Update.t ]
     , Staged_ledger_error.t )
     Deferred.Result.t

val apply_diff_unchecked :
     constraint_constants:Genesis_constants.Constraint_constants.t
  -> global_slot:Mina_numbers.Global_slot_since_genesis.t
  -> logger:Logger.t
  -> current_state_view:Zkapp_precondition.Protocol_state.View.t
  -> state_and_body_hash:State_hash.t * State_body_hash.t
  -> coinbase_receiver:Public_key.Compressed.t
  -> supercharge_coinbase:bool
  -> zkapp_cmd_limit_hardcap:int
  -> signature_kind:Mina_signature_kind.t
  -> t
  -> Staged_ledger_diff.With_valid_signatures_and_proofs.t
  -> ( [ `Ledger_proof of Ledger_proof.Cached.t option ]
       * [ `Staged_ledger of t ]
       * [ `Accounts_created of Account_id.t list ]
       * [ `Pending_coinbase_update of bool * Pending_coinbase.Update.t ]
     , Staged_ledger_error.t )
     Deferred.Result.t

(* This should memoize the snark verifications *)

val create_diff :
     constraint_constants:Genesis_constants.Constraint_constants.t
  -> global_slot:Mina_numbers.Global_slot_since_genesis.t
  -> ?log_block_creation:bool
  -> t
  -> coinbase_receiver:Public_key.Compressed.t
  -> logger:Logger.t
  -> current_state_view:Zkapp_precondition.Protocol_state.View.t
  -> zkapp_cmd_limit:int option
  -> transactions_by_fee:
       Transaction_hash.User_command_with_valid_signature.t Sequence.t
  -> get_completed_work:
       (   Transaction_snark_work.Statement.t
        -> Transaction_snark_work.Checked.t option )
  -> supercharge_coinbase:bool
  -> ( Staged_ledger_diff.With_valid_signatures_and_proofs.t
       * (Transaction_hash.User_command_with_valid_signature.t * Error.t) list
     , Pre_diff_info.Error.t )
     Result.t

(** A block producer is eligible if the account won the slot [winner] has no
    unlocked tokens at slot [global_slot] in the staking ledger [epoch_ledger] *)
val can_apply_supercharged_coinbase_exn :
     winner:Public_key.Compressed.t
  -> epoch_ledger:Mina_ledger.Sparse_ledger.t
  -> global_slot:Mina_numbers.Global_slot_since_genesis.t
  -> bool

val of_scan_state_pending_coinbases_and_snarked_ledger :
     logger:Logger.t
  -> constraint_constants:Genesis_constants.Constraint_constants.t
  -> verifier:Verifier.t
  -> scan_state:Scan_state.t
  -> snarked_ledger:Ledger.t
  -> snarked_local_state:Mina_state.Local_state.t
  -> expected_merkle_root:Ledger_hash.t
  -> pending_coinbases:Pending_coinbase.t
  -> get_state:(State_hash.t -> Mina_state.Protocol_state.value Or_error.t)
  -> signature_kind:Mina_signature_kind.t
  -> t Or_error.t Deferred.t

val of_scan_state_pending_coinbases_and_snarked_ledger_unchecked :
     constraint_constants:Genesis_constants.Constraint_constants.t
  -> logger:Logger.t
  -> scan_state:Scan_state.t
  -> snarked_ledger:Ledger.t
  -> snarked_local_state:Mina_state.Local_state.t
  -> expected_merkle_root:Ledger_hash.t
  -> pending_coinbases:Pending_coinbase.t
  -> get_state:(State_hash.t -> Mina_state.Protocol_state.value Or_error.t)
  -> signature_kind:Mina_signature_kind.t
  -> t Or_error.t Deferred.t

(** All the pending work in t and the data required to generate proofs. *)
val all_work_pairs :
     t
  -> get_state:(State_hash.t -> Mina_state.Protocol_state.value Or_error.t)
  -> ( Transaction_witness.t
     , Ledger_proof.Cached.t )
     Snark_work_lib.Work.Single.Spec.t
     One_or_two.t
     list
     Or_error.t

(** Statements of all the pending work in t*)
val all_work_statements_exn : t -> Transaction_snark_work.Statement.t list

module For_tests : sig
  module Application_state = Application_state
end

module Test_helpers : sig
  val dummy_state_and_view :
       ?global_slot:Mina_numbers.Global_slot_since_genesis.t
    -> unit
    -> Mina_state.Protocol_state.value
       * Zkapp_precondition.Protocol_state.View.t

  val dummy_state_view :
       ?global_slot:Mina_numbers.Global_slot_since_genesis.t
    -> unit
    -> Zkapp_precondition.Protocol_state.View.t

  val update_coinbase_stack_and_get_data_impl :
       logger:Logger.t
    -> constraint_constants:Genesis_constants.Constraint_constants.t
    -> global_slot:Mina_numbers.Global_slot_since_genesis.t
    -> first_partition_slots:int
    -> no_second_partition:bool
    -> is_new_stack:bool
    -> signature_kind:Mina_signature_kind.t
    -> Ledger.t
    -> Pending_coinbase.t
    -> Transaction.t With_status.t list
    -> Zkapp_precondition.Protocol_state.View.t
    -> Frozen_ledger_hash.t * Frozen_ledger_hash.t
    -> ( bool
         * ( Transaction_snark_scan_state.Transaction_with_witness.t
           * Account_id.t list )
           list
         * Pending_coinbase.Update.Action.t
         * [> `Update_none
           | `Update_one of Pending_coinbase.Stack_versioned.t
           | `Update_two of
             Pending_coinbase.Stack_versioned.t
             * Pending_coinbase.Stack_versioned.t ]
         * [> `First_pass_ledger_end of Frozen_ledger_hash.t ]
       , Staged_ledger_error.t )
       Deferred.Result.t
end
