(** {1 Step Verifier - Constraint Generation for Wrap Proof Verification}

    This module generates the constraints used within step circuits to verify
    wrap proofs. These functions do not perform verification directly; instead,
    they build arithmetic constraints that become part of the step circuit.
    The actual verification happens when a prover generates a step proof -
    satisfying these constraints proves that the embedded wrap proof was valid.

    {2 Why Constraint Generation?}

    In recursive SNARKs, we cannot simply "run" a verifier inside a circuit.
    Instead, we express the verification algorithm as arithmetic constraints
    over field elements. When these functions are called during circuit
    construction (in {!Step_main}), they add constraints to the circuit that
    encode what it means for a wrap proof to be valid.

    {2 Where This Module Is Used}

    This module is called from {!Step_main} during step circuit construction:
    - {!val:finalize_other_proof} is called to build constraints for checking
      deferred values from previous wrap proofs
    - {!val:verify} is called to build constraints for full wrap proof
      verification (Fiat-Shamir transcript + IPA + challenge matching)
    - {!val:hash_messages_for_next_step_proof} is called to build constraints
      for hashing accumulated data for the next recursion layer

    {2 Overview}

    The step verifier generates constraints for:
    1. Finalizing "other proofs" - completing deferred scalar-field checks
    2. Incrementally verifying wrap proofs (group operations + IPA)
    3. Hashing messages for the next step/wrap proofs
    4. Managing the Fiat-Shamir transcript (sponge)

    {2 Context: Step Circuit Verification}

    When a step circuit verifies a wrap proof:
    - Group operations (curve additions, scalar mults) are performed directly
    - Scalar-field operations in Tock's scalar field are native (efficient)
    - The IPA is verified incrementally, producing new challenges

    {2 Challenge Generation (Fiat-Shamir)}

    Challenges are generated by:
    1. Absorbing commitments/values into the sponge
    2. Squeezing 128-bit challenges from the sponge
    3. Scalar challenges use the endomorphism for efficiency

    {2 Deferred Verification: Why the Verifier Does Not Fully Verify}

    {b Key design point:} The step verifier does {b not} fully verify the
    polynomial opening proofs (IPA) from wrap proofs. Fully verifying an IPA
    inside a circuit would require O(n) scalar multiplications, which is
    prohibitively expensive. Instead, Pickles uses {e deferred} (or
    {e incremental}) verification:

    {b What {!val:incrementally_verify_proof} does:}
    - Reconstructs the Fiat-Shamir transcript (absorbing commitments, squeezing
      challenges)
    - Verifies that challenges (beta, gamma, alpha, zeta) match the transcript
    - Absorbs the previous challenge polynomial commitments ([sg_old])
    - Computes new bulletproof challenges from the IPA rounds
    - Does {b not} fully verify that the polynomial evaluations are correct

    {b What {!val:finalize_other_proof} does (the deferred checks):}
    - Reconstructs the challenge polynomial [b(X)] from bulletproof challenges
    - Evaluates [b(zeta)] and [b(zeta*omega)]
    - Verifies the combined inner product is consistent with evaluations
    - Verifies PlonK relation constraints
    - These checks are efficient because they use the step circuit's native
      field

    This split is what makes recursion practical. The expensive IPA verification
    is "accumulated" into the challenge polynomial rather than being performed
    directly.

    {2 The Role of sg_old in Recursion}

    The [sg_old] parameter (previous challenge polynomial commitments) is {b the
    core of recursive accumulation}:

    - Each [sg_old] entry is a commitment to a previous proof's challenge
      polynomial [b(X)]
    - These commitments are absorbed into the Fiat-Shamir transcript, binding
      the current proof to its predecessors
    - The verifier does not need to re-verify the IPA from previous proofs;
      instead, it trusts that the [sg_old] commitments correctly encode the
      accumulated IPA state
    - This enables constant-size proofs regardless of recursion depth

    {2 Correspondence with Kimchi Verifier}

    The IVC steps below essentially reimplement the Kimchi verifier as circuit
    constraints. The order and structure of these steps should match the Kimchi
    verifier implementation in Rust. If the code here is difficult to follow,
    refer to the Kimchi verifier for a clearer overview of what each step does:

    - [kimchi/src/verifier.rs] - Main verifier logic

    Maintaining this correspondence is critical for correctness: any divergence
    between the in-circuit verifier and the native Kimchi verifier would break
    the recursive proof system.

    {2 Incremental Verification Flow (incrementally_verify_proof)}

    Each step below corresponds to a comment marker in the implementation.
    To list all steps: [grep -n "== IVC Step" step_verifier.ml]

    {v
    +-------------------------------------------------------------------------+
    |                    FIAT-SHAMIR TRANSCRIPT RECONSTRUCTION                |
    +-------------------------------------------------------------------------+
    |                                                                         |
    |  +------------------+   +------+                                        |
    |  | Verification Key |-->|Sponge|  Step 1: Absorb index digest           |
    |  +------------------+   +--+---+                                        |
    |                            |                                            |
    |  +------------------+      v                                            |
    |  |     sg_old       |-->+------+  Step 2: Absorb sg_old                 |
    |  | (challenge poly  |   |Sponge|  (previous accumulators - binds        |
    |  |  commitments)    |   +--+---+   this proof to predecessors)          |
    |  +------------------+      |                                            |
    |                            |                                            |
    |  +------------------+      |      Step 3: Compute x_hat (public input   |
    |  |  Public Input    |------+              commitment via Lagrange)      |
    |  |   (Lagrange)     |      |                                            |
    |  +------------------+      v      Step 4: Apply blinding to x_hat       |
    |                         +------+                                        |
    |                         |Sponge|  Step 5: Absorb x_hat + w_comm         |
    |  +------------------+   +--+---+                                        |
    |  |     w_comm       |------+                                            |
    |  +------------------+      |                                            |
    |                            v                                            |
    |                      +----------+                                       |
    |                      | beta,    |  Step 6: Squeeze beta, gamma          |
    |                      | gamma    |  (permutation challenges)             |
    |                      +----+-----+                                       |
    |                           |                                             |
    |  +------------------+     v                                             |
    |  |     z_comm       |-->+------+  Step 7: Absorb z_comm                 |
    |  +------------------+   |Sponge|                                        |
    |                         +--+---+                                        |
    |                            |                                            |
    |                            v                                            |
    |                      +----------+                                       |
    |                      | alpha    |  Step 8: Squeeze alpha                |
    |                      +----+-----+  (constraint combiner)                |
    |                           |                                             |
    |  +------------------+     v                                             |
    |  |     t_comm       |-->+------+  Step 9: Absorb t_comm                 |
    |  +------------------+   |Sponge|                                        |
    |                         +--+---+                                        |
    |                            |                                            |
    |                            v                                            |
    |                      +----------+                                       |
    |                      | zeta     |  Step 10: Squeeze zeta                |
    |                      +----+-----+  (evaluation point)                   |
    |                           |                                             |
    |                           v                                             |
    |                    +-------------+                                      |
    |                    |sponge_digest|  Step 11: Save sponge state          |
    |                    +------+------+  (checkpoint for deferred checks)    |
    |                           |                                             |
    +---------------------------+-----------------------------------------+   |
    |                           |     POLYNOMIAL COMMITMENT VERIFICATION  |   |
    |                           |     (partial - IPA deferred via b(X))   |   |
    +---------------------------+-----------------------------------------+   |
    |                           v                                             |
    |  +------------------+   +----------------+                              |
    |  |  Verification    |-->| ft_comm        |  Step 12: Compute ft_comm    |
    |  |  Key + zeta      |   | (linearization)|  (linearization polynomial)  |
    |  +------------------+   +-------+--------+                              |
    |                                 |                                       |
    |                                 v                                       |
    |  +------------------+   +----------------+                              |
    |  |  Opening Proof   |-->| IPA Check      |  Step 13: Partial IPA check  |
    |  |  (L, R, delta,   |   | (incremental)  |  - absorb L, R pairs         |
    |  |   sg = new accum)|   +-------+--------+  - squeeze new challenges    |
    |  +------------------+           |           - deferred (not full check) |
    |                                 v                                       |
    |                         +----------------+                              |
    |                         | New Bulletproof|  Step 14: Assert challenges  |
    |                         | Challenges     |  match + return new accum    |
    |                         | (for next sg)  |  (challenges define new b(X))|
    |                         +----------------+                              |
    |                                                                         |
    +-------------------------------------------------------------------------+
    v}

    {2 Deferred Verification Flow (finalize_other_proof)}

    This is where the deferred IPA verification happens. The key check is
    verifying that [b = b(zeta) + r * b(zeta*omega)] where b(X) is the
    challenge polynomial reconstructed from bulletproof_challenges.

    Each step below corresponds to a comment marker in the implementation.
    To list all steps: [grep -n "== Step" step_verifier.ml | grep -v IVC]

    {v
    +-------------------------------------------------------------------------+
    |                      DEFERRED VALUES VERIFICATION                       |
    |                   (completing the IPA accumulator check)                |
    +-------------------------------------------------------------------------+
    |                                                                         |
    |  +------------------+   +------------------+                             |
    |  | Deferred Values  |   | Feature Flags    |  Step 1: Validate evals    |
    |  | (from wrap)      |   |                  |          match flags       |
    |  +--------+---------+   +--------+---------+                            |
    |           |                      |                                      |
    |           v                      v                                      |
    |  +----------------------------------------+                             |
    |  | Scalar Challenge Conversion            |  Step 2: Convert alpha,     |
    |  | (a,b) -> a + b*endo                    |          zeta, xi via endo  |
    |  +-------------------+--------------------+                             |
    |                      |                                                  |
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | Domain Setup (known or side-loaded)  |   Step 3: Determine domain   |
    |  +-------------------+------------------+                               |
    |                      |                                                  |
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | Compute zeta*omega                   |   Step 4: Second eval point  |
    |  | zetaw = generator * zeta             |                              |
    |  +-------------------+------------------+                               |
    |                      |                                                  |
    +----------------------+--------------------------------------------------+
    |                      |      ACCUMULATOR VERIFICATION (b(X) check)       |
    +----------------------+--------------------------------------------------+
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | Build Challenge Polynomials b(X)     |   Step 5: Reconstruct b(X)   |
    |  | from prev_challenges (sg_olds)       |   from bulletproof challenges|
    |  | b(X) = prod_i (1 + u_i * X^{2^k-1-i})|   (one per previous proof)   |
    |  +-------------------+------------------+                               |
    |                      |                                                  |
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | Evaluate b(X) at zeta and zetaw      |   Step 6: Compute b(zeta),   |
    |  | for each previous proof's challenges |            b(zetaw)          |
    |  +-------------------+------------------+                               |
    |                      |                                                  |
    +----------------------+--------------------------------------------------+
    |                      |      SPONGE RECONSTRUCTION & CHALLENGE CHECK     |
    +----------------------+--------------------------------------------------+
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | Sponge Reconstruction                |   Step 7: Absorb challenge   |
    |  | - Absorb challenge_digest            |            digest, ft_eval1, |
    |  | - Absorb ft_eval1                    |            public input      |
    |  | - Absorb all polynomial evaluations  |            evals, poly evals |
    |  +-------------------+------------------+                               |
    |                      |                                                  |
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | Squeeze and verify xi                |   Step 8: Verify xi matches  |
    |  | Squeeze r (batching challenge)       |            deferred value    |
    |  +-------------------+------------------+                               |
    |                      |                                                  |
    +----------------------+--------------------------------------------------+
    |                      |      PLONK RELATION & INNER PRODUCT CHECKS       |
    +----------------------+--------------------------------------------------+
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | PlonK minimal form + combined evals  |   Step 9: Prepare PlonK      |
    |  | (combine chunked evals into singles) |            data structures   |
    |  +-------------------+------------------+                               |
    |                      |                                                  |
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | Build PlonK scalars environment      |   Step 10: Compute all       |
    |  | (vanishing poly, permutation, etc.)  |             scalar values    |
    |  +-------------------+------------------+                               |
    |                      |                                                  |
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | Combined Inner Product Check         |   Step 11: Verify            |
    |  | actual = sum_i r^i sum_j xi^j f_j()  |   combined_inner_product     |
    |  | Check: actual == deferred value      |   matches claimed value      |
    |  +-------------------+------------------+                               |
    |                      |                                                  |
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | B Value Verification (core IPA check)|   Step 12: Verify b value    |
    |  | actual_b = b(zeta) + r * b(zetaw)    |   This is the accumulator    |
    |  | Check: actual_b == deferred b        |   check that completes IPA   |
    |  +-------------------+------------------+                               |
    |                      |                                                  |
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | PlonK Relation Constraints           |   Step 13: Verify PlonK      |
    |  | (gates + permutation checks)         |            constraints hold  |
    |  +-------------------+------------------+                               |
    |                      |                                                  |
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | Return: all checks passed +          |   Step 14: Combine all       |
    |  |         new bulletproof_challenges   |   all checks + challenges    |
    |  +--------------------------------------+                               |
    |                                                                         |
    +-------------------------------------------------------------------------+
    v}

    {3 See also}

    - {!Step_main} for the step circuit entry point
    - {!Wrap_verifier} for the corresponding wrap-side constraint generator
*)

(** {2 Module Aliases and Core Types} *)

(** The Step circuit implementation from Snarky. Provides field arithmetic,
    boolean operations, and constraint generation for the Tick curve. *)
module Impl := Step_main_inputs.Impl

(** Challenge generation for the Step circuit. Challenges are 128-bit values
    squeezed from the Fiat-Shamir sponge. *)
module Challenge : module type of Import.Challenge.Make (Impl)

(** Digest (hash output) type for the Step circuit. Used for Fiat-Shamir
    transcript hashes and commitment hashes. *)
module Digest : module type of Import.Digest.Make (Impl)

(** Scalar challenges with endomorphism optimization. Scalar challenges encode
    scalars using the curve endomorphism for more efficient in-circuit scalar
    multiplication: a scalar [s] is represented as [s = a + b * endo] where
    [endo] is the endomorphism scalar and [a], [b] are small. *)
module Scalar_challenge :
    module type of
      Scalar_challenge.Make (Impl) (Step_main_inputs.Inner_curve) (Challenge)
        (Endo.Step_inner_curve)

(** Pseudo-selectors for the Step circuit. Used for conditional selection
    based on which branch of the recursive proof is being verified. *)
module Pseudo = Pseudo.Step

(** The inner curve used in the Step circuit (Tick's inner curve, which is
    the Tock/Pasta Vesta curve). Points on this curve are used for
    commitments and the IPA verification. *)
module Inner_curve : sig
  (** A curve point in the circuit (as two field elements for x and y
      coordinates). *)
  type t = Step_main_inputs.Inner_curve.t

  (** Type specification for Inner_curve points, mapping between in-circuit
      representation and constant (out-of-circuit) representation. *)
  val typ : (t, Step_main_inputs.Inner_curve.Constant.t) Impl.Typ.t
end

(** The "other" field, which is Tock's base field (equivalently, Tick's scalar
    field). This is the field where wrap proofs perform their arithmetic. When
    verifying wrap proofs in a step circuit, values from this field must be
    represented as limbs in the native (Tick base) field. *)
module Other_field : sig
  (** A field element from Tock's base field, represented in Step circuit. *)
  type t = Impl.Other_field.t

  (** The number of bits in an Other_field element (approximately 255 bits for
      Pasta curves). *)
  val size_in_bits : int

  (** Type specification for Other_field elements. *)
  val typ : (t, Impls.Step.Other_field.Constant.t) Impls.Step.Typ.t
end

(** {2 Utility Functions} *)

(** [assert_n_bits ~n x] asserts that field element [x] fits in [n] bits.
    Uses scalar challenge conversion which has the side effect of checking
    bit length.
*)
val assert_n_bits : n:int -> Impl.Field.t -> unit

(** {2 Proof Finalization and Verification} *)

(** [finalize_other_proof] generates constraints that complete the deferred
    scalar-field checks from a previous wrap proof.

    {b This is where the deferred IPA verification happens.} When a wrap circuit
    creates a proof, the expensive IPA verification is deferred rather than
    performed in full. This function completes that deferred verification by
    checking the challenge polynomial [b(X)] and the combined inner product.
    The [sg] commitment from the previous proof encodes the accumulated IPA
    state, and this function verifies that state is consistent.

    When a wrap circuit creates a proof, some checks that would be expensive
    in the wrap circuit's native field are deferred. These deferred values
    are passed to the next step circuit, which can perform them efficiently
    since they involve its native field. This function builds the constraints
    to verify those deferred values.

    {3 The Critical b(X) Verification}

    The most important check in this function is verifying the [b] value:
    - Reconstruct the challenge polynomial [b(X)] from [bulletproof_challenges]
    - Evaluate [b(zeta)] and [b(zeta * omega)]
    - Verify that [b = b(zeta) + r * b(zeta * omega)]

    This check ensures the accumulated IPA state (encoded in the previous
    proof's [sg] commitment) is consistent with the claimed evaluations.
    Without this check, a malicious prover could forge IPA opening proofs.

    {3 Type Parameters}

    - ['b]: Number of proofs verified (type-level nat), e.g., [Nat.N2.n]
    - ['a]: Length of bulletproof challenge vectors from previous proofs
    - ['c]: Length of new bulletproof challenge vector
    - ['branches]: Number of circuit branches (for [`Known] step_domains)

    {3 Constraint Generation Steps}

    1. {b Feature flag validation}: Validate evaluation structure matches flags
    2. {b Domain determination}: Determine domain (known or side-loaded)
    3. {b Challenge polynomial evaluation}: Compute sg_olds and evaluate at
       zeta and zetaw
    4. {b Sponge reconstruction}: Absorb challenge digest, ft_eval1, public
       input evaluations, and all polynomial evaluations
    5. {b Challenge verification}: Squeeze xi and r, verify xi matches
    6. {b Combined inner product}: Compute and verify the combined inner product
    7. {b B value verification}: Verify b value was computed correctly -
       {e this is the core IPA accumulation check}
    8. {b PlonK checks}: Verify PlonK arithmetic constraints

    {3 Parameters}

    - First-class module for the number of proofs verified
    - [~step_domains]: Either known domains for each branch or [`Side_loaded]
      for dynamically determined circuits
    - [~zk_rows]: Number of zero-knowledge rows in the constraint system
    - [~sponge]: The Fiat-Shamir sponge state
    - [~prev_challenges]: Previous IPA challenges from earlier recursion layers
    - Deferred values from the wrap proof's proof state
    - All polynomial evaluations from the wrap proof

    {3 Returns}

    A pair of:
    - Boolean indicating whether all deferred checks passed
    - Vector of bulletproof challenges for the next layer
*)
val finalize_other_proof :
     (module Pickles_types.Nat.Add.Intf with type n = 'b)
  -> step_domains:
       [ `Known of (Import.Domains.t, 'branches) Pickles_types.Vector.t
       | `Side_loaded ]
  -> zk_rows:int
  -> sponge:Step_main_inputs.Sponge.t
  -> prev_challenges:
       ((Impl.Field.t, 'a) Pickles_types.Vector.t, 'b) Pickles_types.Vector.t
  -> ( Impl.Field.t
     , Impl.Field.t Import.Scalar_challenge.t
     , Impl.Field.t Pickles_types.Shifted_value.Type1.t
     , ( Impl.Field.t Pickles_types.Shifted_value.Type1.t
       , Impl.Boolean.var )
       Composition_types.Opt.t
     , ( Impl.Field.t Import.Scalar_challenge.t
       , Impl.Boolean.var )
       Composition_types.Opt.t
     , ( Impl.Field.t Import.Scalar_challenge.t Import.Bulletproof_challenge.t
       , 'c )
       Pickles_types.Vector.t
     , Import.Branch_data.Checked.Step.t
     , Impl.Boolean.var )
     Import.Types.Wrap.Proof_state.Deferred_values.In_circuit.t
  -> ( Impl.Field.t
     , Impl.Field.t Core_kernel.Array.t
     , Impl.Boolean.var )
     Pickles_types.Plonk_types.All_evals.In_circuit.t
  -> Impl.Boolean.var * (Impl.Field.t, 'c) Pickles_types.Vector.t

(** {2 Message Hashing for Recursion} *)

(** [hash_messages_for_next_step_proof] creates a staged function that hashes
    the accumulated proof data to produce a commitment for the next recursion
    layer.

    This hash binds together:
    - The verification key index commitments
    - Application-specific state
    - Old bulletproof challenges from previous proofs
    - Commitment data for chaining proofs

    The result is used in the Fiat-Shamir transcript to ensure the prover
    cannot manipulate the recursive proof structure.

    {3 Parameters}

    - [~index]: The verification key polynomial commitments
    - A function to extract field elements from the application state

    {3 Returns}

    A staged function that takes the messages structure and returns the hash
    as a single field element.
*)
val hash_messages_for_next_step_proof :
     index:
       Step_main_inputs.Inner_curve.t array
       Pickles_types.Plonk_verification_key_evals.t
  -> ('s -> Impl.Field.t array)
  -> (   ( 'a
         , 's
         , (Inner_curve.t, 'b) Pickles_types.Vector.t
         , ( (Impl.Field.t, 'c) Pickles_types.Vector.t
           , 'b )
           Pickles_types.Vector.t )
         Import.Types.Step.Proof_state.Messages_for_next_step_proof.t
      -> Impl.Field.t )
     Core_kernel.Staged.t

(** [hash_messages_for_next_step_proof_opt] is a variant of
    {!hash_messages_for_next_step_proof} that supports optional/masked proofs.

    When verifying a variable number of proofs (e.g., 0, 1, or 2 proofs in a
    recursive step), some proof slots may be "dummy" proofs that should not
    contribute to the hash. The [proofs_verified_mask] parameter indicates
    which proofs are real vs dummy.

    {3 Parameters}

    - [~index]: The verification key polynomial commitments
    - A function to extract field elements from the application state

    {3 Returns}

    A pair of:
    - A fresh sponge (for the caller to continue using if needed)
    - A staged function that takes messages and a mask, returning the hash
*)
val hash_messages_for_next_step_proof_opt :
     index:
       Step_main_inputs.Inner_curve.t array
       Pickles_types.Plonk_verification_key_evals.t
  -> ('s -> Impl.Field.t array)
  -> Step_main_inputs.Sponge.t
     * (   ( 'a
           , 's
           , (Inner_curve.t, 'b) Pickles_types.Vector.t
           , ( (Impl.Field.t, 'c) Pickles_types.Vector.t
             , 'b )
             Pickles_types.Vector.t )
           Import.Types.Step.Proof_state.Messages_for_next_step_proof.t
        -> proofs_verified_mask:
             ( Impl.Field.t Snarky_backendless.Boolean.t
             , 'b )
             Pickles_types.Vector.t
        -> Impl.Field.t )
       Core_kernel.Staged.t

(** [verify] generates constraints for full incremental verification of a wrap
    proof within a step circuit.

    This is the core constraint generation function that builds constraints
    checking a wrap proof's validity by:
    1. Reconstructing the Fiat-Shamir transcript and verifying challenges
    2. Generating constraints for polynomial commitment openings via the IPA
    3. Verifying the PlonK relation (gate constraints, permutation argument)
    4. Handling lookup arguments if enabled

    {3 Constraint Generation Steps}

    1. {b Pack statement}: Convert statement to public input array
    2. {b Incremental verification}: Call [incrementally_verify_proof] to
       build constraints for Fiat-Shamir transcript reconstruction and IPA
    3. {b Sponge digest assertion}: Assert computed sponge digest matches
    4. {b Bulletproof challenge assertion}: Assert bulletproof challenges match
       (with special handling for base case)

    {3 Type Parameters}

    - ['a]: Number of proofs verified (type-level nat)

    {3 Parameters}

    - [~proofs_verified]: First-class module specifying number of proofs
    - [~is_base_case]: Whether this is the base case (no previous proofs)
    - [~sg_old]: {b The recursion accumulator} - challenge polynomial
      commitments from previous proofs. Each entry is a curve point encoding
      the accumulated IPA state from a predecessor proof. Absorbed into the
      Fiat-Shamir transcript to bind this proof to its predecessors.
    - [~sponge_after_index]: Sponge state after absorbing the verification key
    - [~lookup_parameters]: Parameters for lookup arguments (if used)
    - [~feature_flags]: Which optional features are enabled in the circuit
    - [~proof]: The wrap proof to verify (commitments and openings)
    - [~srs]: The structured reference string for the polynomial commitment
    - [~wrap_domain]: Domain size, either known or side-loaded
    - [~wrap_verification_key]: The verification key commitments
    - Statement containing public inputs and deferred values
    - Unfinalized proof data from the wrap circuit

    {3 Returns}

    A boolean (as an in-circuit variable) indicating whether the constraints
    for verification are satisfied. When a step proof is generated, the prover
    must satisfy these constraints, proving the wrap proof was valid.
*)
val verify :
     proofs_verified:(module Pickles_types.Nat.Add.Intf with type n = 'a)
  -> is_base_case:Impl.Boolean.var
  -> sg_old:(Impls.Step.Field.t Tuple_lib.Double.t, 'a) Pickles_types.Vector.t
  -> sponge_after_index:Step_main_inputs.Sponge.t
  -> lookup_parameters:
       ( Limb_vector.Challenge.Constant.t
       , Impl.Field.t
       , 'b
       , Impl.Field.t Pickles_types.Shifted_value.Type1.t )
       Composition_types.Wrap.Lookup_parameters.t
       (* lookup arguments parameters *)
  -> feature_flags:Pickles_types.Opt.Flag.t Pickles_types.Plonk_types.Features.t
  -> proof:Wrap_proof.Checked.t
  -> srs:Kimchi_bindings.Protocol.SRS.Fq.t
  -> wrap_domain:
       [ `Known of Import.Domain.t
       | `Side_loaded of
         Composition_types.Branch_data.Proofs_verified.One_hot.Checked.t ]
  -> wrap_verification_key:
       Step_main_inputs.Inner_curve.t array
       Pickles_types.Plonk_verification_key_evals.t
  -> ( Impl.Field.t
     , Impl.Field.t Composition_types.Scalar_challenge.t
     , Impl.Field.t Pickles_types.Shifted_value.Type1.t
     , ( Impl.Field.t Pickles_types.Shifted_value.Type1.t
       , Impl.Boolean.var )
       Pickles_types.Opt.t
     , ( Impl.Field.t Composition_types.Scalar_challenge.t
       , Impl.Field.t Snarky_backendless.Boolean.t )
       Pickles_types.Opt.t
     , Impl.Boolean.var
     , Impl.Field.t
     , Impl.Field.t
     , Impl.Field.t
     , ( Impl.Field.t Kimchi_backend_common.Scalar_challenge.t
         Composition_types.Bulletproof_challenge.t
       , Pickles_types.Nat.z Backend.Tick.Rounds.plus_n )
       Pickles_types.Vector.t
     , Composition_types.Branch_data.Checked.Step.t )
     Import.Types.Wrap.Statement.In_circuit.t
     (* statement *)
  -> Impls.Step.unfinalized_proof_var (* unfinalized *)
  -> Impl.Boolean.var

(** {2 Testing Utilities} *)

(** Internal functions exposed only for testing purposes.
    {b Do not use in production code.} *)
module For_tests_only : sig
  type field := Impl.Field.t

  (** [side_loaded_domain ~log2_size] constructs a domain object for
      side-loaded (dynamically-sized) verification.

      Unlike fixed-size domains where parameters are known at compile time,
      side-loaded domains compute their parameters from the [log2_size]
      provided at runtime. This enables verifying proofs from circuits whose
      size is not known until verification time.

      {3 Returns}

      An object providing:
      - [generator]: The domain's primitive root of unity
      - [log2_size]: The log2 of the domain size (same as input)
      - [shifts]: Coset shifts for the PlonK protocol
      - [vanishing_polynomial]: Function computing Z_H(x) = x^n - 1
  *)
  val side_loaded_domain :
       log2_size:field
    -> < generator : field
       ; log2_size : field
       ; shifts : field Pickles_types.Plonk_types.Shifts.t
       ; vanishing_polynomial : field -> field >
end
