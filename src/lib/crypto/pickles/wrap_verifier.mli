(** {1 Wrap Verifier - Constraint Generation for Step Proof Verification}

    This module generates the constraints used within wrap circuits to verify
    step proofs. These functions do not perform verification directly; instead,
    they build arithmetic constraints that become part of the wrap circuit.
    The actual verification happens when a prover generates a wrap proof -
    satisfying these constraints proves that the embedded step proof was valid.

    {2 Why Constraint Generation?}

    In recursive SNARKs, we cannot simply "run" a verifier inside a circuit.
    Instead, we express the verification algorithm as arithmetic constraints
    over field elements. When these functions are called during circuit
    construction (in {!Wrap_main}), they add constraints to the circuit that
    encode what it means for a step proof to be valid.

    {2 Where This Module Is Used}

    This module is called from {!Wrap_main} during wrap circuit construction:
    - {!val:incrementally_verify_proof} is called to build constraints for
      verifying the step proof's Fiat-Shamir transcript and IPA
    - {!val:finalize_other_proof} is called to build constraints for checking
      deferred values from previous step proofs
    - {!val:choose_key} is called to select the appropriate verification key
      based on which circuit branch is active

    {2 Overview}

    The wrap verifier generates constraints for:
    1. Finalizing "other proofs" - completing deferred scalar-field checks
       from a previous step proof
    2. Incrementally verifying step proofs (group operations + IPA)
    3. Managing the Fiat-Shamir transcript (sponge) with optional absorptions
    4. Selecting verification keys based on which circuit branch is active

    {2 Context: Wrap Circuit Verification}

    When a wrap circuit verifies a step proof:
    - Group operations (curve additions, scalar mults) are performed directly
    - Scalar-field operations in Tick's scalar field are native (efficient)
    - The IPA is verified incrementally, producing new challenges
    - Lookup arguments are handled when the step circuit uses them

    {2 Challenge Generation (Fiat-Shamir)}

    Challenges are generated by:
    1. Absorbing commitments/values into the sponge (with optional masking)
    2. Squeezing 128-bit challenges from the sponge
    3. Scalar challenges use the endomorphism for efficiency

    {2 Correspondence with Kimchi Verifier}

    The IVC steps below essentially reimplement the Kimchi verifier as circuit
    constraints. The order and structure of these steps should match the Kimchi
    verifier implementation in Rust. If the code here is difficult to follow,
    refer to the Kimchi verifier for a clearer overview of what each step does:

    - [kimchi/src/verifier.rs] - Main verifier logic

    Maintaining this correspondence is critical for correctness: any divergence
    between the in-circuit verifier and the native Kimchi verifier would break
    the recursive proof system.

    {2 Incremental Verification Flow (incrementally_verify_proof)}

    {v
    +-------------------------------------------------------------------------+
    |                    FIAT-SHAMIR TRANSCRIPT RECONSTRUCTION                |
    +-------------------------------------------------------------------------+
    |                                                                         |
    |  +------------------+                                                   |
    |  | Verification Key |------+                                            |
    |  +------------------+      |                                            |
    |                            v                                            |
    |  +------------------+   +------+                                        |
    |  |     sg_old       |-->|Sponge|  Step 1-2: Absorb index + sg_old       |
    |  +------------------+   +--+---+                                        |
    |                            |                                            |
    |  +------------------+      |                                            |
    |  |  Public Input    |------+      Step 3-5: Compute x_hat, blind,       |
    |  |   (Lagrange)     |      |               absorb x_hat + w_comm        |
    |  +------------------+      v                                            |
    |  +------------------+   +------+                                        |
    |  |     w_comm       |-->|Sponge|                                        |
    |  +------------------+   +--+---+                                        |
    |                            |                                            |
    |  +------------------+      |      Step 6: Handle lookups (optional)     |
    |  | Lookup tables    |------+      - runtime tables                      |
    |  | (if present)     |      |      - joint_combiner challenge            |
    |  +------------------+      |      - sorted commitments                  |
    |                            v                                            |
    |                      +----------+                                       |
    |                      | beta,    |  Step 7: Squeeze                      |
    |                      | gamma    |  (permutation challenges)             |
    |                      +----+-----+                                       |
    |                           |                                             |
    |  +------------------+     |      Step 8: Absorb lookup aggregation      |
    |  | lookup agg comm  |-----+      (if lookups present)                   |
    |  +------------------+     v                                             |
    |  +------------------+   +------+                                        |
    |  |     z_comm       |-->|Sponge|  Step 9: Absorb z_comm                 |
    |  +------------------+   +--+---+                                        |
    |                            |                                            |
    |                            v      Step 10: Squeeze (scalar challenge)   |
    |                      +----------+                                       |
    |                      | alpha    |  (constraint combiner)                |
    |                      +----+-----+                                       |
    |                           |                                             |
    |  +------------------+     v                                             |
    |  |     t_comm       |-->+------+  Step 11: Absorb t_comm                |
    |  +------------------+   |Sponge|                                        |
    |                         +--+---+                                        |
    |                            |                                            |
    |                            v      Step 12: Squeeze (scalar challenge)   |
    |                      +----------+                                       |
    |                      | zeta     |  (evaluation point)                   |
    |                      +----+-----+                                       |
    |                           |                                             |
    |                           v      Step 13: Save sponge state             |
    |                    +-------------+                                      |
    |                    |sponge_digest|                                      |
    |                    +------+------+                                      |
    |                           |                                             |
    +---------------------------+-----------------------------------------+   |
    |                           |     POLYNOMIAL COMMITMENT VERIFICATION  |   |
    +---------------------------+-----------------------------------------+   |
    |                           v                                             |
    |  +------------------+   +----------------+                              |
    |  |  Verification    |-->| ft_comm        |  Step 14: Linearization      |
    |  |  Key + zeta      |   | (linearization)|          polynomial          |
    |  +------------------+   +-------+--------+                              |
    |                                 |                                       |
    |                                 v                                       |
    |  +------------------+   +----------------+                              |
    |  |  Opening Proof   |-->| IPA Check      |  Step 15: Bulletproof        |
    |  |  (L, R, delta, G)|   |                |          verification        |
    |  +------------------+   +-------+--------+                              |
    |                                 |                                       |
    |                                 v                                       |
    |                         +----------------+                              |
    |                         | Bulletproof    |  Step 16: Return challenges  |
    |                         | Challenges     |          for next layer      |
    |                         +----------------+                              |
    |                                                                         |
    +-------------------------------------------------------------------------+
    v}

    {2 Deferred Verification Flow (finalize_other_proof)}

    {v
    +-------------------------------------------------------------------------+
    |                      DEFERRED VALUES VERIFICATION                       |
    +-------------------------------------------------------------------------+
    |                                                                         |
    |  +------------------+                                                   |
    |  | Deferred Values  |                        Step 1: Convert PlonK      |
    |  | (from step)      |                               values to field     |
    |  +--------+---------+                                                   |
    |           |                                                             |
    |           v                                                             |
    |  +----------------------------------------+                             |
    |  | Compute evaluation points              |  Step 2: zeta, zeta*w       |
    |  | zeta*w = generator * zeta              |                             |
    |  +-------------------+--------------------+                             |
    |                      |                                                  |
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | Challenge Polynomial b(X)            |   Step 3: Build and           |
    |  | Evaluate at zeta and zeta*w          |          evaluate b(X)        |
    |  +-------------------+------------------+                               |
    |                      |                                                  |
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | Sponge Reconstruction                |   Step 4-5: Absorb evals,     |
    |  | Absorb: digest, ft_eval1, evals      |            verify xi          |
    |  | Squeeze: xi, r                       |                               |
    |  +-------------------+------------------+                               |
    |                      |                                                  |
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | PlonK Evaluation Checks              |   Step 6-7: Build minimal     |
    |  | Combined evaluations + scalars env   |            form + env         |
    |  +-------------------+------------------+                               |
    |                      |                                                  |
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | Combined Inner Product               |   Step 8: Verify IPA          |
    |  | sum r^i * (xi*f(zeta) + f(zeta*w))   |           accumulator         |
    |  +-------------------+------------------+                               |
    |                      |                                                  |
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | B Value = b(zeta)*b(zeta*w)*G        |   Step 9: Verify b            |
    |  +-------------------+------------------+                               |
    |                      |                                                  |
    |                      v                                                  |
    |  +--------------------------------------+                               |
    |  | PlonK Relation Constraints           |   Step 10-11: Gate checks,    |
    |  | (gates + permutation)                |              return result    |
    |  +--------------------------------------+                               |
    |                                                                         |
    +-------------------------------------------------------------------------+
    v}

    {3 See also}

    - {!Wrap_main} for the wrap circuit entry point
    - {!Step_verifier} for the corresponding step-side constraint generator
*)

(** {2 Module Aliases and Core Types} *)

(** The Wrap circuit implementation from Snarky. Provides field arithmetic,
    boolean operations, and constraint generation for the Tock curve. *)
module Impl := Impls.Wrap

(** Generic challenge polynomial computation. Given challenges [chals],
    computes the polynomial [prod_i (1 + chals.(i) * x^{2^{k-1-i}})].
    This is used to evaluate the accumulated challenges from previous
    IPA rounds at a given point.

    {3 Parameters}
    - First-class module for field arithmetic
    - Array of challenge values

    {3 Returns}
    A staged function that evaluates the polynomial at a given point.
*)
val challenge_polynomial :
     (module Pickles_types.Shifted_value.Field_intf with type t = 'a)
  -> 'a array
  -> ('a -> 'a) Core_kernel.Staged.t

(** Type alias for step verification key indices, parameterized by
    commitment type and optional commitment type. *)
type ('a, 'a_opt) index' =
  ('a, 'a_opt) Pickles_types.Plonk_verification_key_evals.Step.t

(** Challenge generation for the Wrap circuit. Challenges are 128-bit values
    squeezed from the Fiat-Shamir sponge. *)
module Challenge : module type of Import.Challenge.Make (Impl)

(** Digest (hash output) type for the Wrap circuit. Used for Fiat-Shamir
    transcript hashes and commitment hashes. *)
module Digest : module type of Import.Digest.Make (Impl)

(** Scalar challenges with endomorphism optimization. Scalar challenges encode
    scalars using the curve endomorphism for more efficient in-circuit scalar
    multiplication: a scalar [s] is represented as [s = a + b * endo] where
    [endo] is the endomorphism scalar and [a], [b] are small. *)
module Scalar_challenge :
    module type of
      Scalar_challenge.Make
        (Wrap_main_inputs.Impl)
        (Wrap_main_inputs.Inner_curve)
        (Challenge)
        (Endo.Wrap_inner_curve)

(** {2 Other Field Representation} *)

(** The "other" field, which is Tick's base field (equivalently, Tock's scalar
    field). This is the field where step proofs perform their arithmetic. When
    verifying step proofs in a wrap circuit, values from this field must be
    represented in the native (Tock base) field. *)
module Other_field : sig
  (** Packed representation of other field elements. Used when field elements
      are passed as opaque values without needing bit decomposition. *)
  module Packed : sig
    type t = Impl.Other_field.t

    val typ : (Impl.Impl.Field.t, Backend.Tick.Field.t) Impls.Wrap_impl.Typ.t
  end
end

(** {2 Selection and Masking Utilities} *)

(** One-hot vectors for the Wrap circuit. Used for conditional selection
    based on which branch of the recursive proof is being verified. *)
module One_hot_vector : module type of One_hot_vector.Make (Impl)

(** Pseudo-selectors for the Wrap circuit. Used for selecting values
    based on one-hot encoded branch indices. *)
module Pseudo : module type of Pseudo.Make (Impl)

(** {2 Optional Sponge Operations} *)

(** Optional sponge for handling variable-presence data in the Fiat-Shamir
    transcript. When some proof data may or may not be present (e.g., lookup
    arguments), the optional sponge tracks both possibilities and merges
    them based on runtime flags. *)
module Opt : sig
  include module type of
      Opt_sponge.Make (Impl) (Wrap_main_inputs.Sponge.Permutation)
end

(** {2 Domain Utilities} *)

(** All possible wrap domains for different numbers of proofs verified.
    Memoized for efficiency since these are computed once and reused. *)
val all_possible_domains :
  ( unit
  , ( Pickles_base.Domain.Stable.V1.t
    , Wrap_hack.Padded_length.n Pickles_types.Nat.s )
    Pickles_types.Vector.t )
  Core_kernel.Memo.fn

(** The number of possible wrap domains (one for each possible number of
    proofs verified: 0, 1, or 2). *)
val num_possible_domains :
  Wrap_hack.Padded_length.n Pickles_types.Nat.s Pickles_types.Nat.t

(** {2 Utility Functions} *)

(** [assert_n_bits ~n x] asserts that field element [x] fits in [n] bits.
    Uses scalar challenge conversion which has the side effect of checking
    bit length. *)
val assert_n_bits : n:int -> Impl.Field.t -> unit

(** {2 Constraint Generation for Proof Verification} *)

(** [incrementally_verify_proof] generates constraints for partial verification
    of a step proof within a wrap circuit, reconstructing the Fiat-Shamir
    transcript.

    {3 Constraint Generation Steps}

    1. {b Index absorption}: Hash the verification key to get index_digest
    2. {b Old challenges}: Absorb masked sg_old commitments from previous proofs
    3. {b Public input commitment}: Compute x_hat from public inputs using
       Lagrange basis, apply blinding, and absorb
    4. {b Witness commitments}: Absorb w_comm (witness polynomial commitments)
    5. {b Lookup handling} (if enabled):
       - Absorb runtime table commitments
       - Sample joint_combiner challenge
       - Absorb sorted lookup commitments
    6. {b Beta/gamma sampling}: Squeeze beta and gamma challenges for
       permutation argument
    7. {b Permutation commitment}: Absorb z_comm
    8. {b Alpha sampling}: Squeeze alpha challenge
    9. {b Quotient commitment}: Absorb t_comm
    10. {b Zeta sampling}: Squeeze zeta challenge (evaluation point)
    11. {b Linearization polynomial}: Compute ft_comm from verification key
    12. {b Bulletproof check}: Generate constraints for IPA opening proof
    13. {b Challenge assertion}: Assert sampled challenges match deferred values

    {3 Type Parameters}

    - ['b]: The number of proofs verified (as a type-level natural number)
    - ['a]: The number of circuit branches

    {3 Parameters}

    - First-class module for the number of proofs verified
    - [~actual_proofs_verified_mask]: Boolean mask for which proofs are real
    - [~step_domains]: Domains for each step circuit branch
    - [~srs]: Structured reference string for polynomial commitments
    - [~verification_key]: The step verification key (may vary by branch)
    - [~xi]: Scalar challenge for combining polynomial evaluations
    - [~sponge]: The Fiat-Shamir sponge state
    - [~public_input]: The statement being proven
    - [~sg_old]: challenge polynomial from previous IPA rounds
    - [~advice]: Bulletproof advice (combined inner product, b value)
    - [~messages]: Proof messages (commitments)
    - [~which_branch]: One-hot encoding of which branch is active
    - [~openings_proof]: The IPA opening proof
    - [~plonk]: Deferred PlonK values

    {3 Returns}

    A pair of:
    - The sponge digest before evaluations (for later verification)
    - Success flag and array of bulletproof challenges
*)
val incrementally_verify_proof :
     (module Pickles_types.Nat.Add.Intf with type n = 'b)
  -> actual_proofs_verified_mask:
       ( Wrap_main_inputs.Impl.Field.t Snarky_backendless.Boolean.t
       , 'b )
       Pickles_types.Vector.t
  -> step_domains:(Import.Domains.t, 'a) Pickles_types.Vector.t
  -> srs:Kimchi_bindings.Protocol.SRS.Fp.t
  -> verification_key:
       ( Wrap_main_inputs.Inner_curve.t array
       , ( Wrap_main_inputs.Inner_curve.t array
         , Impl.Boolean.var )
         Pickles_types.Opt.t )
       Pickles_types.Plonk_verification_key_evals.Step.t
  -> xi:Scalar_challenge.t
  -> sponge:Opt.t
  -> public_input:
       [ `Field of
         Wrap_main_inputs.Impl.Field.t * Wrap_main_inputs.Impl.Boolean.var
       | `Packed_bits of Wrap_main_inputs.Impl.Field.t * int ]
       array
  -> sg_old:
       ( Wrap_main_inputs.Impl.Field.t * Wrap_main_inputs.Impl.Field.t
       , 'b )
       Pickles_types.Vector.t
  -> advice:
       Other_field.Packed.t Pickles_types.Shifted_value.Type1.t
       Import.Types.Step.Bulletproof.Advice.t
  -> messages:
       ( Wrap_main_inputs.Impl.Field.t * Wrap_main_inputs.Impl.Field.t
       , Wrap_main_inputs.Impl.Boolean.var )
       Pickles_types.Plonk_types.Messages.In_circuit.t
  -> which_branch:'a One_hot_vector.t
  -> openings_proof:
       ( Wrap_main_inputs.Inner_curve.t
       , Other_field.Packed.t Pickles_types.Shifted_value.Type1.t )
       Pickles_types.Plonk_types.Openings.Bulletproof.t
  -> plonk:
       ( Wrap_main_inputs.Impl.Field.t
       , Wrap_main_inputs.Impl.Field.t Import.Scalar_challenge.t
       , Wrap_main_inputs.Impl.Field.t Pickles_types.Shifted_value.Type1.t
       , ( Wrap_main_inputs.Impl.Field.t Pickles_types.Shifted_value.Type1.t
         , Wrap_main_inputs.Impl.Boolean.var )
         Pickles_types.Opt.t
       , ( Wrap_main_inputs.Impl.Field.t Import.Scalar_challenge.t
         , Wrap_main_inputs.Impl.Boolean.var )
         Pickles_types.Opt.t
       , Wrap_main_inputs.Impl.Boolean.var )
       Import.Types.Wrap.Proof_state.Deferred_values.Plonk.In_circuit.t
  -> Wrap_main_inputs.Impl.Field.t
     * ( [> `Success of Wrap_main_inputs.Impl.Boolean.var ]
       * Scalar_challenge.t Import.Bulletproof_challenge.t Core_kernel.Array.t
       )

(** {2 Constraint Generation for Proof Finalization} *)

(** [finalize_other_proof] generates constraints that complete the deferred
    scalar-field checks from a previous step proof.

    When a step circuit creates a proof, some checks that would be expensive
    in the step circuit's native field are deferred. These deferred values
    are passed to the wrap circuit, which can perform them efficiently
    since they involve its native field. This function builds the constraints
    to verify those deferred values.

    {3 Type Parameters}

    - ['b]: Number of proofs verified (type-level nat), e.g., [Nat.N2.n]
    - ['a]: Length of bulletproof challenge vectors from previous proofs
    - ['c]: Length of new bulletproof challenge vector

    {3 Constraint Generation Steps}

    1. {b Challenge computation}: Convert scalar challenges to field elements
    2. {b Evaluation points}: Compute zetaw = generator * zeta
    3. {b Challenge polynomials}: Evaluate sg_olds at zeta and zetaw
    4. {b Sponge reconstruction}:
       - Absorb challenge digest (hash of old bulletproof challenges)
       - Absorb ft_eval1, public input evaluations
       - Absorb all polynomial evaluations (with optional handling)
    5. {b Challenge verification}: Squeeze xi and r, verify xi matches
    6. {b Combined inner product}: Compute and verify the combined inner
       product used in the bulletproof
    7. {b B value verification}: Verify the b value (challenge polynomial
       evaluation) was computed correctly
    8. {b PlonK checks}: Verify the PlonK relation constraints

    {3 Parameters}

    - First-class module for the number of proofs verified
    - [~domain]: The evaluation domain with generator and vanishing polynomial
    - [~sponge]: The Fiat-Shamir sponge state
    - [~old_bulletproof_challenges]: Previous IPA challenges from earlier
      recursion layers
    - Deferred values from the step proof's proof state
    - All polynomial evaluations from the step proof

    {3 Returns}

    A pair of:
    - Boolean indicating whether all deferred checks passed
    - Vector of bulletproof challenges for the next layer
*)
val finalize_other_proof :
     (module Pickles_types.Nat.Add.Intf with type n = 'b)
  -> domain:
       < generator : Wrap_main_inputs.Impl.Field.t
       ; shifts : Wrap_main_inputs.Impl.Field.t array
       ; vanishing_polynomial : Impl.Field.t -> Impl.Field.t
       ; .. >
  -> sponge:Wrap_main_inputs.Sponge.t
  -> old_bulletproof_challenges:
       ( (Wrap_main_inputs.Impl.Field.t, 'a) Pickles_types.Vector.t
       , 'b )
       Pickles_types.Vector.t
  -> ( Impl.Field.t
     , Impl.Field.t Import.Scalar_challenge.t
     , Impl.Field.t Pickles_types.Shifted_value.Type2.t
     , ( Impl.Field.t Import.Scalar_challenge.t Import.Bulletproof_challenge.t
       , 'c )
       Pickles_types.Vector.t )
     Import.Types.Step.Proof_state.Deferred_values.In_circuit.t
  -> ( Wrap_main_inputs.Impl.Field.t
     , Wrap_main_inputs.Impl.Field.t Array.t
     , Wrap_main_inputs.Impl.Boolean.var )
     Pickles_types.Plonk_types.All_evals.In_circuit.t
  -> Wrap_main_inputs.Impl.Boolean.var
     * (Impl.Field.t, 'c) Pickles_types.Vector.t

(** {2 Verification Key Selection} *)

(** [choose_key which_branch keys] selects the appropriate verification key
    from a vector of keys based on the one-hot encoded branch selector.

    When verifying recursive proofs that may come from different circuit
    branches (e.g., different transaction types), this function masks and
    combines the verification keys so that only the active branch's key
    contributes to the verification.

    {3 Implementation Details}

    The function handles optional commitments (for features like lookups)
    by splitting into three accumulators:
    - [Nothing]: Feature entirely unused across all branches
    - [Just]: Feature used in all branches
    - [Maybe]: Feature used in some but not all branches

    This optimization avoids computing the 'maybe' flag when unnecessary
    and preserves exact serialization for protocol circuits.

    {3 Parameters}

    - [which_branch]: One-hot vector indicating the active branch
    - [keys]: Vector of verification keys, one per branch

    {3 Returns}

    A single verification key that is the masked combination of all input
    keys, where only the active branch contributes non-zero values.
*)
val choose_key :
  'n.
     'n One_hot_vector.t
  -> ( ( Wrap_main_inputs.Inner_curve.t array
       , ( Wrap_main_inputs.Inner_curve.t array
         , Impl.Boolean.var )
         Pickles_types.Opt.t )
       index'
     , 'n )
     Pickles_types.Vector.t
  -> ( Wrap_main_inputs.Inner_curve.t array
     , ( Wrap_main_inputs.Inner_curve.t array
       , Impl.Boolean.var )
       Pickles_types.Opt.t )
     index'
